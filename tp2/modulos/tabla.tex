\section{Tabla}

\subsection{Interfaz}

\iusa{}
\iseexplica{Tabla}
\igenero{tabla}

\ioperaciones

\begin{itemize}
    \item{$n$ es la cantidad de registros presentes en la tabla}
    \item{$L$ es el máximo de largo de un dato string}
    \item{La cantidad de campos se asume acotada por constante}
    \item{Los nombres de tablas y campos se asumen acotados por constante}
\end{itemize}

\operacion{NuevaTabla}
{   \param{in}{$nombre$}{$string$},
    \param{in}{$claves$}{$conj(campos)$},
    \param{in}{$columnas$}{$registro$}} % parametros
{tabla} % tipo res
{$\neg\emptyset?(claves) \land claves \subseteq campos(columnas)$} % pre
{res \igobs nuevaTabla()} % post
{\bigo(1)} % complejidad
{Los parámetros pasados no deben ser modificados luego} % aliasing
{} % descripcion

\operacion{AgregarRegistro}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{r}{$registro$}}
{}
{$t \igobs t_0 \land campos(r) \igobs campos(t) \land puedoInsertar?(r,t)$}
{$t$ \igobs agregarRegistro(r,$t_0$)}
{L + \bigo($in$)}
{}
{$in$ es \bigo($log(n)$) si hay un indice sobre un campo de tipo NAT, \bigo(1) sino. \\
 }

\operacion{BorrarRegistro}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{$conj(registro)$}
{$t \igobs t_0 \land c \in claves(t) \land_L tipo?(d) \igobs tipoCampo(c,t)$}
{$t$ \igobs borrarRegistro($crit,t_0$)}
{\bigo($L + in$)}
{}
{$in$ es \bigo($log(n)$) si el campo de borrado es un índice, \bigo($n$) sino}

\operacion{Indexar}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{c}{$campo$}}
{}
{$t \igobs t_0 \land puedeIndexar(c,t)$}
{$t$ \igobs indexar($c,t_0$)}
{\bigo(in)}
{}
{in es O(log(n)) en promedio si hay un indice sobre un campo de tipo NAT, O(n) sino}

\operacion{Nombre}
{   \param{in}{$t$}{$tabla$}}
{string}
{true}
{$res \igobs nombre(t)$}
{\bigo(1)}
{No se debe modificar la string retornada}
{}

\operacion{EsClave}
{   \param{in}{$t$}{$tabla$}
    \param{in}{$c$}{$campo$}}
{bool}
{true}
{$res \igobs c \in claves(t$}
{\bigo(1)}
{}
{La complejidad es \bigo($|campos| * cmp(string)$), pero ambos entán acotados}

\operacion{EsIndice}
{   \param{in}{$t$}{$tabla$}
    \param{in}{$c$}{$campo$}}
{bool}
{true}
{$res \igobs indices(t$}
{\bigo(1)}
{}
{}

\operacion{Campos}
{   \param{in}{$t$}{$tabla$}}
{conj(campo)}
{true}
{$res \igobs campos(t)$}
{\bigo(1)}
{No se debe modificar el conjunto retornado}
{}

\operacion{Accesos}
{   \param{in}{$t$}{$tabla$}}
{nat}
{true}
{$res \igobs cantidadDeAccesos(t)$}
{\bigo(1)}
{}
{}

\operacion{MaxNat}
{   \param{in}{$t$}{$tabla$}}
{nat}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t) \land
    res \igobs valorNat(maximo(c,t))$}
{\bigo(1)}
{}
{}

\operacion{MinNat}
{   \param{in}{$t$}{$tabla$}}
{nat}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t) \land
    res \igobs valorNat(minimo(c,t))$}
{\bigo(1)}
{}
{}

\operacion{MaxString}
{   \param{in}{$t$}{$tabla$}}
{string}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t) \land
    res \igobs valorString(maximo(c,t))$}
{\bigo(1)}
{No se debe modificar el resultado}
{}

\operacion{MinString}
{   \param{in}{$t$}{$tabla$}}
{string}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t) \land
    res \igobs valorString(minimo(c,t))$}
{\bigo(1)}
{No se debe modificar el resultado}
{}

\operacion{Buscar}
{   \param{in}{$t$}{$tabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{conj(registro)}
{$c \in campos(t) \land_L tipo?(d) \igobs tipoCampo(c,t)$}
{$ $}
{\bigo(in)}
{No se debe modificar los resultados}
{in es $log(n) * L$ si $c$ es índice, $n * L$ sino}

\subsection{Representación}

-- todo: explicacion --

\serepresenta{tabla}{vec}
\donde{vec}{tupla($registros$: regs, $hayIndiceNat$: bool, $indiceNat$: campo, $indicesNat$: treeNat, \\
    $hayIndiceString$: bool, $indiceString$: campo, $indicesString$: treeString, \\
    $maxminNat$: mmNat, $maxminString$: mmString, \\
    $nombre$: nombreTabla, $campos$: registro, $claves$: conj($campo$), $accesos$: nat)}

\donde{regs}{conj($registro$)}
\donde{treeNat}{diccAvl($nat$, itConj($registro$))}
\donde{treeString}{diccAvl($string$, itConj($registro$))}
\donde{mmNat}{tupla($max$: nat, $min$: nat)}
\donde{mmString}{tupla($max$: string, $min$: string)}

\donde{campo}{string}
\donde{nombreTabla}{string}
\donde{registro}{diccAvl($campo$, $dato$)}

\subsubsection{Invariante de representación}

\begin{Rep}{$estr$}{$e$}
    \repfunc{Hay claves y están incluidas en campos}
        {\neg\emptyset?(e.claves) \land e.claves \subseteq claves(e.campos)}

    \repfunc{Los registros tienen los mismos campos y del mismo tipo}
        {(\forall r : registro) (r \in e.registros \implies claves(r) = claves(e.campos) \land_L \\
        \hspace*{2em} (\forall c : campo) (c \in claves(r) \implies_L \; tipo?(obtener(c,r)) = tipo?(obtener(c,e.campos))))}

    \repfunc{Si no hay indice de tipo nat, indicesNat está vacio}
        {\neg e.hayIndiceNat \implies \emptyset?(e.indicesNat)}

    \repfunc{Si hay indice de tipo nat, indiceNat es un campo válido e indicesNat tiene los registros referenciados por el índice}
        {e.hayIndiceNat \implies indiceNat \in claves(e.campos) \land_L Nat?(obtener(indiceNat,e.campos)) \land_L \\
        \hspace*{2em} \#e.registros = \#claves(e.indicesNat) \land \\
        \hspace*{2em} (\forall r : registro) (r \in e.registros \implies def?(obtener(indiceNat,r), e.indicesNat) \land_L \\
        \hspace*{12em} haySiguiente?(obtener(obtener(indiceNat,r), e.indicesNat)) \land_L \\
        \hspace*{12em} Siguiente(obtener(obtener(indiceNat,r), e.indicesNat)) \igobs r)}

    \repfunc{Si no hay indice de tipo string, indicesString está vacio}
        {\neg e.hayIndiceString \implies \emptyset?(e.indicesString)}

    \repfunc{Si hay indice de tipo string, indiceString es un campo válido e indicesString tiene los registros referenciados por el índice}
        {e.hayIndiceString \implies indiceString \in claves(e.campos) \land_L String?(obtener(indiceString,e.campos)) \land_L \\
        \hspace*{2em} \#e.registros = \#claves(e.indicesString) \land \\
        \hspace*{2em} (\forall r : registro) (r \in e.registros \implies def?(obtener(indiceString,r), e.indicesString) \land_L \\
        \hspace*{12em} haySiguiente?(obtener(obtener(indiceString,r), e.indicesString)) \land_L \\
        \hspace*{12em} Siguiente(obtener(obtener(indiceString,r), e.indicesString)) \igobs r)}

    \repfunc{Hay por lo menos tantos accesos como registros insertados}
        {e.accesos \ge \#e.registros}

    \repfunc{Los max/min son válidos}
        {e.hayIndiceString \land long(e.registros) \implies (\\
        \hspace*{2em} valorString(max(dameColumna(e.indiceString,e.registros))) \igobs e.maxminString.max \land \\
        \hspace*{2em} valorString(min(dameColumna(e.indiceString,e.registros))) \igobs e.maxminString.min) \land \\
        e.hayIndiceNat \land long(e.registros) \implies (\\
        \hspace*{2em} valorNat(max(dameColumna(e.indiceNat,e.registros))) \igobs e.maxminNat.max \land \\
        \hspace*{2em} valorNat(min(dameColumna(e.indiceNat,e.registros))) \igobs e.maxminNat.min)\\
    }

\end{Rep}

\subsubsection{Función de abstracción}

\begin{ABS}{$e$}{$estr$}{$t$}{$tabla$}
    \absfunc{}{e.nombre \igobs nombre(t) \; \land}
    \absfunc{}{e.claves \igobs claves(t) \; \land}
    \absfunc{}{e.registros \igobs r \in registros(t) \; \land}
    \absfunc{}{e.accesos \igobs cantidadDeAccesos(t) \; \land}
    \absfunc{}
        {(\IFM e.hayIndiceNat THEN Ag(indiceNat, \emptyset) ELSE \emptyset FI) \: \cup \\
        (\IFM e.hayIndiceString THEN Ag(indiceString, \emptyset) ELSE \emptyset FI) \igobs indices(t) \; \land}
    \absfunc{}{claves(e.campos) \igobs campos(t) \; \land_L}
    \absfunc{}{(\forall c : campo) \: (c \in claves(e.campos) \implies_L \: tipo?(obtener(c,e.campos)) \igobs tipoCampo(c,t))}
\end{ABS}

\subsection{Algoritmos}

\algoritmo{iNuevaTabla}{
        \param{in}{$nombre$}{$string$},
        \param{in}{$claves$}{$conj(campos)$},
        \param{in}{$columnas$}{$registro$}
        }{tabla}{\bigo(1)}{
    \State $res.registros \gets nuevoDiccAvl()$                     \comment \bigo(1)
    \State $res.hayIndiceNat \gets false$                           \comment \bigo(1)
    \State $res.hayIndiceString \gets false$                        \comment \bigo(1)
    \State $res.nombre \gets nombre$                                \comment \bigo(1)
    \State $res.campos \gets columnas$                              \comment \bigo(1)
    \State $res.claves \gets claves$                                \comment \bigo(1)
    \State $res.accesos \gets 0$                                    \comment \bigo(1)
}

\algoritmo{iAgregarRegistro}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$r$}{$registro$}
        }{}{\bigo($L + in$)}{
    \var $it : itConj(registro)$
    \State $it \gets AgregarRapido(t.registros, r)$                 \comment \bigo($L$)

    \If{$t.hayIndiceNat$}
        \var $k : nat$
        \State $k \gets getNat(significado(r, t.indiceNat))$        \comment \bigo(1)
        \State $definirRapido(t.indicesNat, k, it)$                 \comment \bigo($log(n)$)
    \EndIf
    \If{$t.hayIndiceString$}
        \var $k : string$
        \State $k \gets getString(significado(r, t.indiceString))$  \comment \bigo(1)
        \State $definirRapido(t.indicesString, k, it)$
                                    \comment Como la máxima cantidad de valores del índice string es \bigo($2^L$),
        \Statex                     \comment insertar un nuevo valor del índice se hace en \bigo($log(2^L)$) $=$ \bigo($L$)
    \EndIf
}

\algoritmo{iBorrarRegistro}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$},
        \param{in}{$d$}{$dato$}
        }{$conj(registro)$}{\bigo($L + in$)}{
    \var $esta : bool$
    \var $it : itConj(registro)$
    \var $r : registro$
    \State $res \gets vacio()$                                      \comment \bigo(1)
    \State $esta \gets false$                                       \comment \bigo(1

    \State
    \If{$t.hayIndiceNat \algAnd t.indiceNat == c$}                  \comment \bigo(1)
        \If{$definido(t.indicesNat,getNat(d))$}                     \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesNat, getNat(d))$  \comment \bigo($log(n)$)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \ElsIf{$t.hayIndiceString \algAnd t.indiceString == c$}         \comment \bigo(1)
        \If{$definido(t.indicesString,getString(d))$}               \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesString, getString(d))$        \comment \bigo($log(n)$)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \Else
        \State $it \gets crearIt(t.registros)$                      \comment \bigo(1)
        \While{$haySiguiente(it) \algAnd significado(siguiente(it),c) \!= d$}   \comment \bigo($1$)
            \Statex             \comment El loop se repite a lo sumo $n$ veces
            \State avanzar(it)                                      \comment \bigo(1)
        \EndWhile
        \If{haySiguiente(it)}                                       \comment \bigo(1)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \EndIf

    \State
    \If{$esta$}
        \State $r \gets copiar(siguiente(it))$                      \comment \bigo($L$)
        \State $agregarRapido(res, r)$                              \comment \bigo(1)
        \State $eliminarSiguiente(it)$                              \comment \bigo(1)
        \If{$t.hayIndiceNat$}                                       \comment \bigo(1)
            \State $borrar(t.indicesNat, significado(r, t.indiceNat))$          \comment \bigo($log(n)$)
        \EndIf
        \If{$t.hayIndiceString$}                                    \comment \bigo(1)
            \State $borrar(t.indicesString, significado(r, t.indiceString))$    \comment \bigo($log(n)$)
        \EndIf
    \EndIf
}

\subsection{Servicios usados}

