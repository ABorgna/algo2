\section{Tabla}

\subsection{Interfaz}

\iusa{}
\iseexplica{Tabla}
\igenero{tabla}

\ioperaciones

\begin{itemize}
    \item{$n$ es la cantidad de registros presentes en la tabla}
    \item{$L$ es el máximo de largo de un dato string}
    \item{La cantidad de campos se asume acotada por constante}
    \item{Los nombres de tablas y campos se asumen acotados por constante}
\end{itemize}

\operacion{NuevaTabla}
{   \param{in}{$nombre$}{$string$},
    \param{in}{$claves$}{$conj(campos)$},
    \param{in}{$columnas$}{$registro$}} % parametros
{tabla} % tipo res
{$\neg\emptyset?(claves) \land claves \subseteq campos(columnas)$} % pre
{res \igobs nuevaTabla()} % post
{\bigo(1)} % complejidad
{Los parámetros pasados no deben ser modificados luego} % aliasing
{} % descripcion

\operacion{AgregarRegistro}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{r}{$registro$}}
{}
{$t \igobs t_0 \land campos(r) \igobs campos(t) \land puedoInsertar?(r,t)$}
{$t$ \igobs agregarRegistro(r,$t_0$)}
{L + \bigo($in$)}
{}
{$in$ es \bigo($log(n)$) si hay un indice sobre un campo de tipo NAT, \bigo(1) sino. \\
 }

\operacion{BorrarRegistro}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{$conj(registro)$}
{$t \igobs t_0 \land c \in claves(t) \land_L tipo?(d) \igobs tipoCampo(c,t)$}
{$t \igobs borrarRegistro(crit,t_0)$}
{\bigo($L + in$)}
{}
{$in$ es \bigo($log(n)$) si el campo de borrado es un índice, \bigo($n$) sino}

\operacion{Indexar}
{   \param{in/out}{$t$}{$tabla$},
    \param{in}{c}{$campo$}}
{}
{$t \igobs t_0 \land puedeIndexar(c,t)$}
{$t \igobs indexar(c,t_0)$}
{\bigo($n \; log(n)$)}
{}
{}

\operacion{Nombre}
{   \param{in}{$t$}{$tabla$}}
{string}
{true}
{$res \igobs nombre(t)$}
{\bigo(1)}
{No se debe modificar la string retornada}
{}

\operacion{EsClave}
{   \param{in}{$t$}{$tabla$}
    \param{in}{$c$}{$campo$}}
{bool}
{$c \in campos(t)$}
{$res \igobs c \in claves(t$}
{\bigo(1)}
{}
{La complejidad es \bigo($|campos| * cmp(string)$), pero ambos entán acotados}

\operacion{EsIndice}
{   \param{in}{$t$}{$tabla$}
    \param{in}{$c$}{$campo$}}
{bool}
{$c \in campos(t)$}
{$res \igobs c \in indices(t$}
{\bigo(1)}
{}
{}

\operacion{Campos}
{   \param{in}{$t$}{$tabla$}}
{registro}
{true}
{$claves(res) \igobs campos(t) \land_L \\
    \hspace*{5em} (\forall c : campo) c \in campos(t) \implies_L \; tipo?(obtener(c,res)) \igobs tipoCampo(c,t)$}
{\bigo(1)}
{No se debe modificar el conjunto retornado}
{}

\operacion{TipoCampo}
{   \param{in}{$t$}{$tabla$},
    \param{in}{$c$}{$campo$}}
{bool}
{$c \in campos(t)$}
{$res \igobs tipoCampo(c,t)$}
{\bigo(1)}
{}
{}

\operacion{Accesos}
{   \param{in}{$t$}{$tabla$}}
{nat}
{true}
{$res \igobs cantidadDeAccesos(t)$}
{\bigo(1)}
{}
{}

\operacion{MaxNat}
{   \param{in}{$t$}{$tabla$}}
{nat}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t) \land
    res \igobs valorNat(maximo(c,t))$}
{\bigo(1)}
{}
{}

\operacion{MinNat}
{   \param{in}{$t$}{$tabla$}}
{nat}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L tipoCampo(c,t) \land
    res \igobs valorNat(minimo(c,t))$}
{\bigo(1)}
{}
{}

\operacion{MaxString}
{   \param{in}{$t$}{$tabla$}}
{string}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t) \land
    res \igobs valorString(maximo(c,t))$}
{\bigo(1)}
{No se debe modificar el resultado}
{}

\operacion{MinString}
{   \param{in}{$t$}{$tabla$}}
{string}
{$\neg\emptyset?(registros(t)) \land
    (\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t)$}
{$(\exists c : campo) c \in indices(t) \land_L \neg tipoCampo(c,t) \land
    res \igobs valorString(minimo(c,t))$}
{\bigo(1)}
{No se debe modificar el resultado}
{}

\operacion{Buscar}
{   \param{in}{$t$}{$tabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{conj(registro)}
{$c \in campos(t) \land_L tipo?(d) \igobs tipoCampo(c,t)$}
{$ $}
{\bigo(in)}
{No se debe modificar los resultados}
{in es $log(n) * L$ si $c$ es índice, $n * L$ sino}

\subsection{Representación}

-- todo: explicacion --

\serepresenta{tabla}{vec}
\donde{vec}{tupla($registros$: regs, $hayIndiceNat$: bool, $indiceNat$: campo, $indicesNat$: treeNat, \\
    $hayIndiceString$: bool, $indiceString$: campo, $indicesString$: treeString, \\
    $nombre$: nombreTabla, $campos$: registro, $claves$: conj($campo$), $accesos$: nat)}

\donde{regs}{conj($registro$)}
\donde{treeNat}{diccLog($nat$, itConj($registro$))}
\donde{treeString}{diccLog($string$, itConj($registro$))}

\donde{campo}{string}
\donde{nombreTabla}{string}
\donde{registro}{diccLog($campo$, $dato$)}

\subsubsection{Invariante de representación}

\begin{Rep}{$estr$}{$e$}
    \repfunc{Hay claves y están incluidas en campos}
        {\neg\emptyset?(e.claves) \land e.claves \subseteq claves(e.campos)}

    \repfunc{Los registros tienen los mismos campos y del mismo tipo}
        {(\forall r : registro) (r \in e.registros \implies claves(r) = claves(e.campos) \land_L \\
        \hspace*{2em} (\forall c : campo) (c \in claves(r) \implies_L \; tipo?(obtener(c,r)) = tipo?(obtener(c,e.campos))))}

    \repfunc{Si no hay indice de tipo nat, indicesNat está vacio}
        {\neg e.hayIndiceNat \implies \emptyset?(e.indicesNat)}

    \repfunc{Si hay indice de tipo nat, indiceNat es un campo válido e indicesNat tiene los registros referenciados por el índice}
        {e.hayIndiceNat \implies indiceNat \in claves(e.campos) \land_L Nat?(obtener(indiceNat,e.campos)) \land_L \\
        \hspace*{2em} \#e.registros = \#claves(e.indicesNat) \land \\
        \hspace*{2em} (\forall r : registro) (r \in e.registros \implies def?(obtener(indiceNat,r), e.indicesNat) \land_L \\
        \hspace*{12em} haySiguiente?(obtener(obtener(indiceNat,r), e.indicesNat)) \land_L \\
        \hspace*{12em} Siguiente(obtener(obtener(indiceNat,r), e.indicesNat)) \igobs r)}

    \repfunc{Si no hay indice de tipo string, indicesString está vacio}
        {\neg e.hayIndiceString \implies \emptyset?(e.indicesString)}

    \repfunc{Si hay indice de tipo string, indiceString es un campo válido e indicesString tiene los registros referenciados por el índice}
        {e.hayIndiceString \implies indiceString \in claves(e.campos) \land_L String?(obtener(indiceString,e.campos)) \land_L \\
        \hspace*{2em} \#e.registros = \#claves(e.indicesString) \land \\
        \hspace*{2em} (\forall r : registro) (r \in e.registros \implies def?(obtener(indiceString,r), e.indicesString) \land_L \\
        \hspace*{12em} haySiguiente?(obtener(obtener(indiceString,r), e.indicesString)) \land_L \\
        \hspace*{12em} Siguiente(obtener(obtener(indiceString,r), e.indicesString)) \igobs r)}

    \repfunc{Hay por lo menos tantos accesos como registros insertados}
        {e.accesos \ge \#e.registros}

\end{Rep}

\subsubsection{Función de abstracción}

\begin{ABS}{$e$}{$estr$}{$t$}{$tabla$}
    \absfunc{}{e.nombre \igobs nombre(t) \; \land}
    \absfunc{}{e.claves \igobs claves(t) \; \land}
    \absfunc{}{e.registros \igobs r \in registros(t) \; \land}
    \absfunc{}{e.accesos \igobs cantidadDeAccesos(t) \; \land}
    \absfunc{}
        {(\IFM e.hayIndiceNat THEN Ag(indiceNat, \emptyset) ELSE \emptyset FI) \: \cup \\
        (\IFM e.hayIndiceString THEN Ag(indiceString, \emptyset) ELSE \emptyset FI) \igobs indices(t) \; \land}
    \absfunc{}{claves(e.campos) \igobs campos(t) \; \land_L}
    \absfunc{}{(\forall c : campo) \: (c \in claves(e.campos) \implies_L \: tipo?(obtener(c,e.campos)) \igobs tipoCampo(c,t))}
\end{ABS}

\subsection{Algoritmos}

\algoritmo{iNuevaTabla}{
        \param{in}{$nombre$}{$string$},
        \param{in}{$claves$}{$conj(campos)$},
        \param{in}{$columnas$}{$registro$}
        }{tabla}{\bigo(1)}{
    \State $res.registros \gets nuevoDiccLog()$                     \comment \bigo(1)
    \State $res.hayIndiceNat \gets false$                           \comment \bigo(1)
    \State $res.hayIndiceString \gets false$                        \comment \bigo(1)
    \State $res.nombre \gets nombre$                                \comment \bigo(1)
    \State $res.campos \gets columnas$                              \comment \bigo(1)
    \State $res.claves \gets claves$                                \comment \bigo(1)
    \State $res.accesos \gets 0$                                    \comment \bigo(1)
}

\algoritmo{iAgregarRegistro}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$r$}{$registro$}
        }{}{\bigo($L + in$)}{
    \var $it : itConj(registro)$
    \State $it \gets AgregarRapido(t.registros, r)$                 \comment \bigo($L$)

    \If{$t.hayIndiceNat$}
        \var $k : nat$
        \State $k \gets getNat(significado(r, t.indiceNat))$        \comment \bigo(1)
        \State $definirRapido(t.indicesNat, k, it)$                 \comment \bigo($log(n)$)
    \EndIf
    \If{$t.hayIndiceString$}
        \var $k : string$
        \State $k \gets getString(significado(r, t.indiceString))$  \comment \bigo(1)
        \State $definirRapido(t.indicesString, k, it)$
                                    \comment Como la máxima cantidad de valores del índice string es \bigo($2^L$),
        \Statex                     \comment insertar un nuevo valor del índice se hace en \bigo($log(2^L)$) $=$ \bigo($L$)
    \EndIf
    \State
    \State $t.accesos \gets t.accesos + 1$                          \comment \bigo(1)
}

\algoritmo{iBorrarRegistro}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$},
        \param{in}{$d$}{$dato$}
        }{$conj(registro)$}{\bigo($L + in$)}{
    \var $esta : bool$
    \var $it : itConj(registro)$
    \State $res \gets vacio()$                                      \comment \bigo(1)
    \State $esta \gets false$                                       \comment \bigo(1)

    \State
    \If{$t.hayIndiceNat \algAnd t.indiceNat == c$}                  \comment \bigo(1)
        \If{$definido(t.indicesNat,getNat(d))$}                     \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesNat, getNat(d))$  \comment \bigo($log(n)$)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \ElsIf{$t.hayIndiceString \algAnd t.indiceString == c$}         \comment \bigo(1)
        \If{$definido(t.indicesString,getString(d))$}               \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesString, getString(d))$        \comment \bigo($log(n)$)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \Else
        \State $it \gets crearIt(t.registros)$                      \comment \bigo(1)
        \While{$haySiguiente(it) \algAnd significado(siguiente(it),c) \;!= d$}   \comment \bigo(1)
            \Statex             \comment El loop se repite a lo sumo $n$ veces
            \State avanzar(it)                                      \comment \bigo(1)
        \EndWhile
        \If{haySiguiente(it)}                                       \comment \bigo(1)
            \State $esta \gets true$                                \comment \bigo(1)
        \EndIf
    \EndIf

    \State
    \If{$esta$}
        \var $r : registro$
        \State $r \gets copiar(siguiente(it))$                      \comment \bigo($L$)
        \State $agregarRapido(res, r)$                              \comment \bigo(1)
        \State $eliminarSiguiente(it)$                              \comment \bigo(1)
        \If{$t.hayIndiceNat$}                                       \comment \bigo(1)
            \State $borrar(t.indicesNat, significado(r, t.indiceNat))$          \comment \bigo($log(n)$)
        \EndIf
        \If{$t.hayIndiceString$}                                    \comment \bigo(1)
            \State $borrar(t.indicesString, significado(r, t.indiceString))$    \comment \bigo($log(n)$)
        \EndIf

        \State
        \State $t.accesos \gets t.accesos + 1$                      \comment \bigo(1)
    \EndIf
}

\algoritmo{iIndexar}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$}
        }{}{\bigo($n \; log(n)$)}{
        \var it : itConj(registro)
        \State $it \gets crearIt(t.registros)$                      \comment \bigo(1)

        \If{tipoCampo(t,c)}                                         \comment \bigo(1)
            \State $t.hayIndiceNat \gets true$                      \comment \bigo(1)
            \State $t.indiceNat \gets c$                            \comment \bigo(1)
            \State $t.indicesNat \gets vacio()$                     \comment \bigo(1)
            \While{$haySiguiente(it)$}                              \comment \bigo(1)
                \Statex             \comment El loop se repite a lo sumo $n$ veces
                \State $definirRapido(t.indicesNat, significado(siguiente(it),c), copy(it))$
                                                                    \comment \bigo($log(n)$)
                \State $avanzar(it)$                                \comment \bigo(1)
            \EndWhile
        \Else
            \State $t.hayIndiceString \gets true$                   \comment \bigo(1)
            \State $t.indiceString \gets c$                         \comment \bigo(1)
            \State $t.indicesString \gets vacio()$                  \comment \bigo(1)
            \While{$haySiguiente(it)$}                              \comment \bigo(1)
                \Statex             \comment El loop se repite a lo sumo $n$ veces
                \State $definirRapido(t.indicesString, significado(siguiente(it),c), copy(it))$
                                                                    \comment \bigo($log(n)$)
                \State $avanzar(it)$                                \comment \bigo(1)
            \EndWhile
        \EndIf
}

\algoritmo{iNombre}{
        \param{in}{$t$}{$tabla$}
        }{string}{\bigo(1)}{
        \State $res \gets t.nombre$                                 \comment \bigo(1)
}

\algoritmo{iEsClave}{
        \param{in}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$}
        }{bool}{\bigo(1)}{
        \var $it : itConj(campo)$
        \State $it \gets crearIt(t.claves)$                         \comment \bigo(1)

        \While{$haySiguiente(it) \algAnd siguiente(it) \;!= c$}     \comment \bigo(1)
            \Statex     \comment El loop se repite a lo sumo $|campos|$ veces, acotado por constante
            \State avanzar(it)                                      \comment \bigo(1)
        \EndWhile
        \State $res \gets haySiguiente(it)$                         \comment \bigo(1)
}

\algoritmo{iEsIndice}{
        \param{in}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$}
        }{bool}{\bigo(1)}{
        \If{tipoCampo(t,c)}                                         \comment \bigo(1)
            \State $res \gets c == t.indiceNat$                     \comment \bigo(1)
        \Else
            \State $res \gets c == t.indiceString$                  \comment \bigo(1)
        \EndIf
}

\algoritmo{iCampos}{
        \param{in}{$t$}{$tabla$}
        }{registro}{\bigo(1)}{
        \State $res \gets t.campos$                                 \comment \bigo(1)
}

\algoritmo{iTipoCampo}{
        \param{in}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$}
        }{registro}{\bigo(1)}{
        \State $res \gets isNat(significado(t.campos,c))$           \comment \bigo(1)
}

\algoritmo{iAccesos}{
        \param{in}{$t$}{$tabla$}
        }{nat}{\bigo(1)}{
        \State $res \gets t.accesos$                                \comment \bigo(1)
}

\algoritmo{maxNat}{
        \param{in}{$t$}{$tabla$}
        }{nat}{\bigo(1)}{
        \State $res \gets maximo(t.indicesNat)_0$                   \comment \bigo(1)
}

\algoritmo{minNat}{
        \param{in}{$t$}{$tabla$}
        }{nat}{\bigo(1)}{
        \State $res \gets minimo(t.indicesNat)_0$                   \comment \bigo(1)
}

\algoritmo{maxString}{
        \param{in}{$t$}{$tabla$}
        }{string}{\bigo(1)}{
        \State $res \gets maximo(t.indicesString)_0$                \comment \bigo(1)
}

\algoritmo{minString}{
        \param{in}{$t$}{$tabla$}
        }{string}{\bigo(1)}{
        \State $res \gets minimo(t.indicesString)_0$                \comment \bigo(1)
}

\algoritmo{iBuscar}{
        \param{in/out}{$t$}{$tabla$},
        \param{in}{$c$}{$campo$},
        \param{in}{$d$}{$dato$}
        }{$conj(registro)$}{\bigo($L + in$)}{
    \var $it : itConj(registro)$
    \State $res \gets vacio()$                                      \comment \bigo(1)

    \State
    \If{$t.hayIndiceNat \algAnd t.indiceNat == c$}                  \comment \bigo(1)
        \If{$definido(t.indicesNat,getNat(d))$}                     \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesNat, getNat(d))$  \comment \bigo($log(n)$)
            \State $agregarRapido(res, siguiente(it))$              \comment \bigo($L$)
        \EndIf
    \ElsIf{$t.hayIndiceString \algAnd t.indiceString == c$}         \comment \bigo(1)
        \If{$definido(t.indicesString,getString(d))$}               \comment \bigo($log(n)$)
            \State $it \gets significado(t.indicesString, getString(d))$        \comment \bigo($log(n)$)
            \State $agregarRapido(res, siguiente(it))$              \comment \bigo($L$)
        \EndIf
    \Else
        \State $it \gets crearIt(t.registros)$                      \comment \bigo(1)
        \While{$haySiguiente(it)$}                                  \comment \bigo(1)
            \Statex             \comment El loop se repite $n$ veces
            \If{$significado(siguiente(it),c) = d$}
                \State $agregarRapido(res, siguiente(it))$          \comment \bigo($L$)
            \EndIf
            \State avanzar(it)                                      \comment \bigo(1)
        \EndWhile
    \EndIf
}

\subsection{Servicios usados}

