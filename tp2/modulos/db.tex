\section{BaseDeDatos}

\subsection{Interfaz}

\iusa{}
\iseexplica{BaseDeDatos}
\igenero{db}

\ioperaciones

\subsection{Representación}

-- todo: explicacion --

\serepresenta{db}{vec}
\donde{vec}{tupla($tablas$: tablas, $tablasTree$: tablasTree, $vistasJoin$: vistas, $tablaMaxima$: maxima)}
\donde{tablas}{conj($tabla$)}
\donde{tablasTree}{diccTrie($nombreTabla$, itConj($tabla$))}
\donde{maxima}{puntero($tabla$)}
\donde{vistas}{diccTrie($nombreTabla$, diccTrie($nombreTabla$, $vistaJoin$))}
\donde{vistaJoin}{tupla($campo$: campo, $buffer$: buffer, $joinsNat$: jNat, $joinsString$, jString)}
\donde{jNat}{diccAvl($nat$, $registro$)}
\donde{jString}{diccAvl($string$, $registro$)}
\donde{buffer}{lista($operacionJoin$)}
\donde{operacionJoin}{tupla($esInsercion$: bool, $insertado$: puntero($registro$), $borrado$: registro)}

\donde{nombreTabla}{string}
\donde{campo}{string}
\donde{registro}{diccAvl($campo$,$dato$)}

\subsubsection{Invariante de representación}

\begin{Rep}{$estr$}{$e$}
    \repfunc{tablasTree tiene las tablas}
        {\#e.tablas = \#claves(e.tablasTree) \land \\
        (\forall t : tabla) (t \in e.tablas \implies def?(nombre(t), e.tablasTree) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(nombre(t), e.tablasTree)) \land_L \\
        \hspace*{10em} Siguiente(obtener(nombre(t, e.tablasTree)) \igobs t))}

    \repfunc{vistasJoin tiene tablas válidas}
        {(\forall nt : nombreTabla) (def?(nt, e.vistasJoin) \implies \\
        \hspace*{4em} def?(nt, e.tablasTree) \land_L \\
        \hspace*{4em} (\forall nt' : nombreTabla) (def?(nt', obtener(nt,e.vistasJoin)) \implies \\
        \hspace*{8em} def?(nt', e.tablasTree))}

    \repfunc{El campo de las vistasJoin es válido}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists c : campo) \; (\exists t_a, t_b : tabla) \; c \igobs obtener(nt',obtener(nt,e.vistasJoin)).campo \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \hspace*{6em} c \in claves(t_a) \land \\
        \hspace*{6em} c \in claves(t_b) \land_L \\
        \hspace*{6em} tipoCampo(c, t_a) \igobs tipoCampo(c, t_b)}

    \repfunc{Los joins cacheados en vistasJoins tienen las entradas que tienen que tener}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists c : campo) \; (\exists t_a, t_b : tabla) \; c \igobs obtener(nt',obtener(nt,e.vistasJoin)).campo \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \hspace*{6em} \#combinarRegistros(c, registros(t_a), registros(t_b)) \igobs \\
        \hspace*{8em} (\IFLM tipoCampo(c, obtener(nt, e.tablasTree)) THEN \\
        \hspace*{10em} \#claves(obtener(nt',obtener(nt,e.vistasJoin)).joinsNat) \\
        \hspace*{8em} ELSE \\
        \hspace*{10em} \#claves(obtener(nt',obtener(nt,e.vistasJoin)).joinsString) \\
        \hspace*{8em} FI) \land \\
        \hspace*{6em} (\forall r : registro) r \in combinarRegistros(c, registros(t_a), registros(t_b)) \implies_L (\\
        \hspace*{8em} \IFLM tipoCampo(c, obtener(nt, e.tablasTree)) THEN \\
        \hspace*{10em} def?(valorNat(obtener(c,r)), \\
        \hspace*{13em} obtener(c,obtener(nt',obtener(nt,e.vistasJoin)).joinsNat)) \land_L \\
        \hspace*{10em} obtener(valorNat(obtener(c,r)), \\
        \hspace*{13em} obtener(c,obtener(nt',obtener(nt,e.vistasJoin)).joinsNat)) \igobs r \\
        \hspace*{8em} ELSE \\
        \hspace*{10em} def?(valorString(obtener(c,r)), \\
        \hspace*{13em} obtener(c,obtener(nt',obtener(nt,e.vistasJoin)).joinsString)) \land_L \\
        \hspace*{10em} obtener(valorString(obtener(c,r)), \\
        \hspace*{13em} obtener(c,obtener(nt',obtener(nt,e.vistasJoin)).joinsString)) \igobs r \\
        \hspace*{8em} FI) \\
    \text{// todo: no estabos tomando en cuenta el buffer}}

    \repfunc{Buffer}{\text{// todo}}

    \repfunc{Si hay tablas, e.tablaMaxima apunta a la tabla máxima}{}

\end{Rep}

\subsubsection{Función de abstracción}

\begin{ABS}{$e$}{$estr$}{$db$}{$base$}
    \absfunc{}{(\forall nt : nombreTabla) \: nt \in tablas(db) \iff (\exists t : tabla) (nombre(t) = nt \land esta?(t, e.tablas)) \; \land_L }
    \absfunc{}{(\forall t : tabla) \: esta?(t, e.tablas) \implies_L \; dameTabla(nombre(t), db) \igobs t \; \land}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) \: nt \in tablas(db) \land nt' \in tablas(db) \implies \\
        \hspace*{4em} (hayJoin?(nt, nt', db) \iff def?(nt, e.vistasJoin) \;\land_L\; def?(nt', obtener(nt, e.vistasJoin))) \; \land_L}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) hayJoin?(nt, nt', db) \implies \\
        \hspace*{4em} campoVistaJoin(obtener(nt', obtener(nt, e.vistasJoin))) \igobs campoJoin(nt, nt', db)}
\end{ABS}

\subsection{Algoritmos}

\subsection{Servicios usados}

