\section{BaseDeDatos}

\subsection{Interfaz}

\iusa{}
\iseexplica{BaseDeDatos}
\igenero{db}

\ioperaciones

\begin{itemize}
    \item{$T$ es la cantidad de tablas en la db}
    \item{$n$ y $m$ son la cantidad de registros presentes en las tablas sobre las que se opera}
    \item{$L$ es el máximo largo de un dato string}
    \item{La cantidad de campos se asume acotada por constante}
    \item{Los nombres de tablas y campos se asumen acotados por constante}
\end{itemize}

\operacion{NuevaDB}
{} % parametros
{base} % tipo res
{} % pre
{$res \igobs nuevaDB()$} % post
{\bigo(1)} % complejidad
{} % aliasing
{} % descripcion

\operacion{AgregarTabla}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$t$}{$tabla$}}
{}
{$db \igobs db_0 \land \emptyset?(registros(t)) \land \neg(nombre(t) \in tablas(db))$}
{$db \igobs agregarTabla(t,db_0)$}
{\bigo(1)}
{No se debe modificar la tabla después de insertada}
{}

\operacion{InsertarEntrada}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}}
{}
{$db \igobs db_0 \land nt \in tablas(db) \land_L puedoInsertar?(r,dameTabla(nt,db))$}
{$db \igobs insertarEntrada(t,db_0)$}
{\bigo($T * L + in$)}
{}
{$in$ es \bigo($log(n)$) si hay un índice sobre un campo de tipo NAT, \bigo(1) sino}

\operacion{Borrar}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{}
{$db \igobs db_0 \land nt \in tablas(db) \land c \in claves(dameTabla(nt,db)) \land_L \\
    \hspace*{4em} tipo?(d) \igobs tipoCampo(c,dameTabla(nt,db))$}
{$db \igobs borrar(definir(c,d,vacio),db_0)$}
{\bigo($T * L + log(n)$) si el campo de borrado es un índice, \bigo($L * (T + n)$) sino}
{}
{}

\operacion{GenerarVistaJoin}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$}, \\ \hspace*{9.6em}
    \param{in}{$nt_2$}{$nombreTabla$},
    \param{in}{$c$}{$campo$}}
{itConj(registro)}
{$db \igobs db_0 \land nt_2 \in tablas(db) \land nt_1 \in tablas(db) \land nt_1 \neq nt_2 \land_L \\
    \hspace*{4em} c \in claves(dameTabla(nt_1,db)) \land c \in claves(dameTabla(nt_2,db)) \land_L \\
    \hspace*{4em} tipoCampo(c,dameTabla(nt_1,db)) \igobs tipoCampo(c,dameTabla(nt_2,db)) \land \\
    \hspace*{4em} \neg hayJoin?(nt_1,nt_2,db)$}
{$db \igobs generarVistaJoin(nt_1,nt_2,c,db_0) \land_L \\
    \hspace*{4em} alias(esPermutacion?(SecuSuby(res), vistaJoin(nt_1, nt_2, db))) \land vacia?(Anteriores(res))$}
{\bigo($min(n,m) * (L + log(n + m))$) si el campo es indice de ambas tablas, \\
    \hspace*{4em} \bigo($n * (L + log(n + m))$) si el campo es sólo índice de $t_2$, \\
    \hspace*{4em} \bigo($m * (L + log(n + m))$) si el campo es sólo índice de $t_1$ y \\
    \hspace*{4em} \bigo($m * (n * L + log(n))$) si el campo no es un índice, \\
    \hspace*{4em} donde $n = |registros(t_1)|$ y $m = |registros(t_2)|$}
{}
{}

\operacion{HayTabla}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}}
{$bool$}
{$true$}
{$res \igobs nt \in tablas(db)$}
{\bigo(1)}
{}
{}

\operacion{Tabla}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}}
{$tabla$}
{$nt \in tablas(db)$}
{$res \igobs dameTabla(nt,db)$}
{\bigo(1)}
{No se debe modificar la tabla devuelta}
{}

\operacion{Tablas}
{   \param{in}{$db$}{$base$}}
{$itConj(tabla)$}
{true}
{$alias(esPermutacion?(SecuSuby(res), getTablasConj(tablas(db), db))) \land vacia?(Anteriores(res))$}
{\bigo(1)}
{No se debe modificar las tablas}
{El iterador devuelto tiene $siguiente()$ en \bigo(1)}

\operacion{TablaMaxima}
{   \param{in}{$db$}{$base$}}
{$tabla$}
{$\#tablas(db) > 0$}
{$res \igobs dameTabla(tablaMaxima(db),db)$}
{\bigo(1)}
{No se debe modificar la tabla devuelta}
{}

\operacion{HayJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$bool$}
{$true$}
{$res \igobs hayJoin?(nt_1,nt_2,db)$}
{\bigo(1)}
{}
{}

\operacion{CampoJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$campo$}
{$hayJoin?(nt_1,nt_2,db)$}
{$res \igobs campoJoin(nt_1,nt_2,db)$}
{\bigo(1)}
{}
{}

\operacion{BorrarJoin}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{}
{$db \igobs db_0 \land hayJoin?(nt_1,nt_2,db)$}
{$db \igobs borrar(nt_1,nt_2,db_0)$}
{\bigo(1)}
{}
{}

\operacion{VistaJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$itConj(registro)$}
{$hayJoin?(nt_1,nt_2,db)$}
{$alias(esPermutacion?(SecuSuby(res), vistaJoin(nt_1, nt_2, db))) \land vacia?(Anteriores(res))$}
{\bigo(1) si $R = 0$, \\
    \hspace*{4em} \bigo($R * (L + log(n * m))$) si $R > 0$ y ambas tablas tienen índice en el campo del join y \\
    \hspace*{4em} \bigo($R * L * (n + m)$) sino \\
    \hspace*{4em} R es la cantidad de modificaciónes sobre las tablas desde la generación o última visualización del join}
{No se debe modificar los resultados}
{}

\operacion{Buscar}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}}
{conj(registro)}
{$nt \in tablas(db) \land_L (\exists t : tabla) \; (t \igobs dameTabla(nt,db) \land \\
    \hspace*{4em} claves(r) \subseteq campos(t) \land_L
        (\forall c : campo) c \in claves(r) \implies_L tipo?(obtener(c,r)) \igobs tipoCampo(c,t))$}
{$res \igobs buscar(r,nt,db)$}
{\bigo($L$) si hay un campo clave e índice string como criterio, \\
    \hspace*{4em} \bigo($L + log(n)$) si hay un campo clave e índice nat, \\
    \hspace*{4em} \bigo($L * n$) si no, \\
    \hspace*{4em} donde $n = |registros(dameTabla(nt,db)|)$}
{No se debe modificar los resultados}
{}

\subsubsection{Operaciones auxiliares de la interfaz}

\tadOperacion{getTablasConj}{conj(string)/nts, base/db}{conj(tabla)}{$nts \subseteq tablas(db)$}

\tadAxiomas[$\forall db : base, \forall nts : conj(string), \forall as : conj(\alpha)$]

\tadAxioma{getTablasConj(nts,db)}{\IF $\emptyset?$(nts) THEN $\emptyset$ ELSE Ag(dameTabla(dameUno(nts),db), getTablasConj(sinUno(nts),db)) FI}

\subsection{Representación}

La estructura mantine un conjunto de tablas y un índice sobre sus nombres basado en un trie.

Cada join se mantiene cacheado con un conjunto de los registros resultantes y un índices sobre el campo del join usando un avl o un trie según su tipo. También se mantiene una cola de modificaciónes sobre una lista enlazada que se procesa al pedir el resultado del join.

Por último, se mantiene un puntero a una de las tablas con mas modificaciones.

\vspace*{2em}

\serepresenta{db}{vec}
\donde{vec}{tupla($tablas$: tablas, $tablasTree$: tablasTree, $vistasJoin$: vistas, $tablaMaxima$: maxima)}
\donde{tablas}{conj($tabla$)}
\donde{tablasTree}{diccTrie($nombreTabla$, itConj($tabla$))}
\donde{maxima}{itConj($tabla$)}
\donde{vistas}{diccTrie($nombreTabla$, diccTrie($nombreTabla$, $vistaJoin$))}
\donde{vistaJoin}{tupla($campo$: campo, $tipo$: bool, $buffer$: buffer, \\
    $joins$: joins, $joinsNat$: jNat, $joinsString$: jString)}
\donde{joins}{conj($registro$)}
\donde{joinsNat}{diccLog($nat, itConj(registro)$)}
\donde{joinsString}{diccTrie($itConj(registro)$)}
\donde{buffer}{lista($operacionJoin$)}
\donde{operacionJoin}{tupla($esInsercion$: bool, $enTablaB$: bool, $reg$: $registro$)}

\donde{nombreTabla}{string}
\donde{campo}{string}
\donde{registro}{diccLog($campo$,$dato$)}

\subsubsection{Invariante de representación}

\begin{Rep}{$estr$}{$e$}
    \repfunc{tablasTree tiene las tablas}
        {\#e.tablas = \#claves(e.tablasTree) \land \\
        (\forall t : tabla) (t \in e.tablas \implies def?(nombre(t), e.tablasTree) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(nombre(t), e.tablasTree)) \land_L \\
        \hspace*{10em} Siguiente(obtener(nombre(t, e.tablasTree)) \igobs t))}

    \repfunc{vistasJoin tiene tablas válidas}
        {(\forall nt : nombreTabla) (def?(nt, e.vistasJoin) \implies \\
        \hspace*{4em} def?(nt, e.tablasTree) \land_L \\
        \hspace*{4em} (\forall nt' : nombreTabla) (def?(nt', obtener(nt,e.vistasJoin)) \implies \\
        \hspace*{8em} def?(nt', e.tablasTree))}

    \repfunc{El campo de las vistasJoin es válido}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\ \\
        \hspace*{6em} v.campo \in claves(t_a) \land \\
        \hspace*{6em} v.campo \in claves(t_b) \land_L \\
        \hspace*{6em} tipoCampo(v.campo, t_a) \igobs tipoCampo(v.campo, t_b) \land \\
        \hspace*{6em} v.tipo \igobs tipoCampo(v.campo, t_b) }

    \repfunc{Los registros de cada buffer tienen los campos de las tablas correspondientes}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op : operacionJoin) \; op \in v.buffer \implies \\
        \hspace*{8em} \IFLM \neg op.enTablaB THEN \\
        \hspace*{10em} campos(op.reg) \igobs campos(t_a) \land_L mismosTipos(op.reg, t_a) \\
        \hspace*{8em} ELSE \\
        \hspace*{10em} campos(op.reg) \igobs campos(t_b) \land_L mismosTipos(op.reg, t_b) \\
        \hspace*{8em} FI
    }

    \repfunc{Los joins cacheados tienen los campos de ambas tablas}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) \; r \in v.joins \implies (\\
        \hspace*{10em} campos(r) \igobs campos(t_a) \cup campos(t_b) \land \\
        \hspace*{10em} (\forall c : campo) \; c \in campos(r) \implies (\\
        \hspace*{12em} (c \in campos(t_a) \land_L tipoCampo(c,t_a) \igobs tipo?(obtener(c,r))) \lor \\
        \hspace*{12em} (c \in campos(t_b) \land_L tipoCampo(c,t_b) \igobs tipo?(obtener(c,r)))))
    }

    \repfunc{Los diccionarios de índices de los joins tienen todas las entradas}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} \IFLM v.tipo THEN \\
        \hspace*{8em} \#v.joins \igobs \#claves(v.joinsNat) \land \\
        \hspace*{8em} (\forall r : registro) \; r \in v.joins \implies \\
        \hspace*{10em} def?(valorNat(obtener(v.campo, r)), v.joinsNat) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(valorNat(obtener(v.campo, r)), v.joinsNat)) \land_L \\
        \hspace*{10em} siguiente(obtener(valorNat(obtener(v.campo, r)), v.joinsNat)) \igobs r \\
        \hspace*{6em} ELSE \\
        \hspace*{8em} \#v.joins \igobs \#claves(v.joinsString) \land \\
        \hspace*{8em} (\forall r : registro) \; r \in v.joins \implies \\
        \hspace*{10em} def?(valorString(obtener(v.campo, r)), v.joinsString) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(valorString(obtener(v.campo, r)), v.joinsString)) \land_L \\
        \hspace*{10em} siguiente(obtener(valorString(obtener(v.campo, r)), v.joinsString)) \igobs r \\
        \hspace*{6em} FI
    }

    \repfunc{No hay dos inserciones seguidas en un buffer (sin borrar antes)}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op, op' : operacionJoin) \; (op \in v.buffer \; \land \; op' \in v.buffer \; \land_L \\
        \hspace*{10em} op.esInsercion \; \land \; op'.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg)) \implies \\
        \hspace*{8em} (\exists op'' : operacionJoin) \; (op'' \in v.buffer \; \land_L \\
        \hspace*{10em} \neg op''.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg) \; \land \\
        \hspace*{10em} estaDespues?(op'', op, v.buffer) \; \land \\
        \hspace*{10em} estaDespues?(op', op'', v.buffer))
    }

    \repfunc{No hay inserciones de indices ya cacheados en un buffer (sin borrar antes)}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall d : dato) \; (\forall op : operacionJoin) \; (op \in v.buffer \; \land \; op.esInsercion \land \\
        \hspace*{10em} datoIndexado?(d,v.joinsNat,v.joinsString) \; \land_L obtener(v.campo, op.reg) \igobs d ) \implies \\
        \hspace*{8em} (\exists op' : operacionJoin) \; (op' \in v.buffer \; \land_L \neg op'.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op'.reg) \igobs d \; \land  estaDespues?(op', op, v.buffer))
    }

    \repfunc{Todos los joins posibles están cacheados en vistasJoins y no hay modificaciones en el buffer, o la inserción está en el buffer y no se la borra luego}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) r \in combinarRegistros(v.campo, registros(t_a), registros(t_b)) \implies_L (\\
        \hspace*{8em} (r \in v.joins \land \\
        \hspace*{10em} \neg(\exists op' : operacionJoin) \; (op' \in v.buffer \; \land \\
        \hspace*{12em} obtener(v.campo,r) \igobs obtener(v.campo, op'.reg))) \lor \\
        \hspace*{8em} ((\exists op : operacionJoin) \; op \in v.buffer \; \land \; op.esInsercion \; \land_L \\
        \hspace*{10em} coincidenTodos(r, campos(op.reg), op.reg) \land \\
        \hspace*{10em} \neg(\exists op' : operacionJoin) \; (op' \in v.buffer \; \land \\
        \hspace*{12em} obtener(v.campo,r) \igobs obtener(v.campo,op'.reg) \land \\
        \hspace*{12em} estaDespues?(op', op, v.buffer))))}

    \repfunc{vistasJoins tiene joins válidos o joins que seran eliminados}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) \; r \in v.joins \implies_L (\\
        \hspace*{10em} r \in combinarRegistros(v.campo, registros(t_a), registros(t_b))\\
        \hspace*{8em}  \lor \\
        \hspace*{8em} ((\exists op : operacionJoin) \; op \in v.buffer \; \land_L \\
        \hspace*{10em} obtener(v.campo,r) \igobs obtener(v.campo,op.reg)))}

    \repfunc{Si hay inserciones de joins no válidos en el buffer, también está su eliminación}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op : operacionJoin) \; (op \in v.buffer \land op.esInsercion \land \\
        \hspace*{16em} \emptyset?(coincidencias(op.reg, \\
        \hspace*{18em} combinarRegistros(v.campo, registros(t_a), \\
        \hspace*{20em} registros(t_b))))) \implies \\
        \hspace*{8em} ((\exists op' : operacionJoin) \; op' \in v.buffer \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg) \; \land \\
        \hspace*{10em} estaDespues?(op', op, v.buffer))}

    \repfunc{Si hay tablas, e.tablaMaxima apunta a una de las tablas con mas cantidadDeAccesos}
        {\neg\emptyset?(e.tablas) \implies \\
        \hspace*{4em} haySiguiente?(e.tablaMaxima) \land_L \\
        \hspace*{4em} siguiente(e.tablaMaxima) \in e.tablas \land \\
        \hspace*{4em} (\forall t : tabla) \; t \in e.tablas \implies \\
        \hspace*{8em} cantidadDeAccesos(t) \leq cantidadDeAccesos(siguiente(e.tablaMaxima)) \\
        }

\end{Rep}

\subsubsection{Operaciones auxiliares del invariante de representación}

\tadOperacion{estaDespues?}{$\alpha$/a, $\alpha$/b, secu($\alpha$)}{bool}{esta?(a,s) $\land$ esta?(b,s)}
\tadOperacion{datoIndexado?}{d/dato, dicc(nat\,$\alpha$)/dn, dicc(string\,$\beta$)/ds}{bool}{}

\tadAxiomas[\paratodo{secu($\alpha$)}{s}, \paratodo{$\alpha$}{a,b}]

\tadAxioma{estaDespues?(a,b,s)}{$\neg$(prim(s) $=$ a) $\land_L$ (prim(s) $=$ b $\lor_L$ estaDespues?(a,b,fin(s)))}
\tadAxioma{datoIndexado?(d,dn,ds)}{\IF Nat?(d) THEN valorNat(d) $\in$ claves(dn) ELSE valorString(d) $\in$ claves(ds) FI}

\subsubsection{Función de abstracción}

\begin{ABS}{$e$}{$estr$}{$db$}{$base$}
    \absfunc{}{tablas(db) \igobs claves(e.tablasTree) \; \land_L }
    \absfunc{}{(\forall t : tabla) \: t \in e.tablas \implies_L \; dameTabla(nombre(t), db) \igobs t \; \land}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) \: nt \in tablas(db) \land nt' \in tablas(db) \implies \\
        \hspace*{4em} (hayJoin?(nt, nt', db) \iff def?(nt, e.vistasJoin) \;\land_L\; def?(nt', obtener(nt, e.vistasJoin))) \; \land_L}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) hayJoin?(nt, nt', db) \implies \\
        \hspace*{4em} obtener(nt', obtener(nt, e.vistasJoin)).campo \igobs campoJoin(nt, nt', db)}
\end{ABS}

\subsection{Algoritmos}

\algoritmo{iNuevaDB}{}{base}{\bigo(1)}{
    \State $res.tablas \gets vacio()$                               \comment \bigo(1)
    \State $res.tablasTree \gets nuevoDiccLog()$                    \comment \bigo(1)
    \State $res.vistasJoin \gets nuevoTrie()$                       \comment \bigo(1)
}{4 * \bigo(1) = \bigo(1)}

\algoritmo{iAgregarTabla}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$t$}{$tabla$}
    }{}{\bigo(1)}{
    \var $it : itConj(tabla)$
    \State $it \gets agregarRapido(db.tablas, t)$                   \comment \bigo(1)
    \State $definir(db.tablasTree, nombre(t), it)$                  \comment \bigo($|nombre(t)|$) = \bigo(1)
    \If{$cardinal(db.tablas) == 1$}                                 \comment \bigo(1)
        \State $db.tablaMaxima = it$                                \comment \bigo(1)
    \EndIf
}{4 * \bigo(1) = \bigo(1)}

\algoritmo{iInsertarEntrada}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}
    }{}{\bigo($T * L + log(n)$) si hay un índice nat, \bigo($T * L$) sino}{
    \var $t : tabla$
    \var $it : itConj(tabla)$
    \State $t \gets tabla(db,nt)$                                   \comment \bigo(1)
    \State $it \gets tablas(db)$                                    \comment \bigo(1)
    \State $agregarRegistro(t,r)$                                   \comment \bigo($L + log(n)$) si hay un índice nat, \bigo($L$) sino
    \If{$accesos(siguiente(db.tablaMaxima)) < accesos(t)$}          \comment \bigo(1)
        \State $db.tablaMaxima = obtener(db.tablasTree,nt)$         \comment \bigo(1)
    \EndIf
    \State
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State                 \icomment El loop se repite $T$ veces
        \var $t' : tabla$
        \State $t' \gets siguiente(it)$                             \comment \bigo(1)
        \If{$nombre(t') \;!= nombre(t)$}                            \comment \bigo($|nombre(t)|$) = \bigo(1)
            \If{$definido?(db.vistasJoin, nombre(t))$}              \comment \bigo($|nombre(t)|$) = \bigo(1)
                \var $joinsT : diccTrie(nombreTabla, vistaJoin)$
                \State $joinsT \gets obtener(db.vistasJoin, nombre(t))$                 \comment \bigo($|nombre(t)|$) = \bigo(1)
                \If{$definido?(joinsT, nombre(t'))$}                \comment \bigo($|nombre(t')|$) = \bigo(1)
                    \var $b : buffer$
                    \State $b \gets obtener(joinsT, nombre(t')).buffer$                 \comment \bigo($|nombre(t')|$) = \bigo(1)
                    \State $agregarAtras(b, <esInsercion: true, tabla: false, reg: r>)$ \comment \bigo($copy(registro)$) = \bigo($L$)
                \EndIf
            \EndIf
            \State
            \If{$definido?(db.vistasJoin, nombre(t'))$}             \comment \bigo($|nombre(t')|$) = \bigo(1)
                \var $joinsT' : diccTrie(nombreTabla, vistaJoin)$
                \State $joinsT' \gets obtener(db.vistasJoin, nombre(t'))$               \comment \bigo($|nombre(t')|$) = \bigo(1)
                \If{$definido?(joinsT', nombre(t))$}                \comment \bigo($|nombre(t)|$) = \bigo(1)
                    \var $b : buffer$
                    \State $b \gets obtener(joinsT', nombre(t)).buffer$                 \comment \bigo($|nombre(t)|$) = \bigo(1)
                    \State $agregarAtras(b, <esInsercion: true, tabla: true, reg: r>)$  \comment \bigo($copy(registro)$) = \bigo($L$)
                \EndIf
            \EndIf
        \EndIf
        \State $avanzar(it)$                                        \comment \bigo(1)
    \EndWhile
}{Si hay un índice nat: 2 * \bigo(1) + \bigo($L + log(n)$) + 2 * \bigo(1) \\
    \hspace*{16em} + $T$ * (6 * \bigo(1) + \bigo($L$) + 4 * \bigo(1) + \bigo($L$) + \bigo(1)) = \bigo($T * L + log(n)$)
    \hspace*{8.25em} Sino: 2 * \bigo(1) + \bigo($L$) + 2 * \bigo(1)
    + $T$ * (6 * \bigo(1) + \bigo($L$) + 4 * \bigo(1) + \bigo($L$) + \bigo(1)) = \bigo($T * L$)
}

\algoritmo{iBorrar}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}
    }{}{\bigo($T * L + log(n)$) si c es un índice, \bigo($L * (T + n)$) sino}{
    \var $t : tabla$
    \var $it : itConj(tabla)$
    \var $rs : conj(registro)$
    \State $t \gets tabla(db,nt)$                                   \comment \bigo(1)
    \State $it \gets tablas(db)$                                    \comment \bigo(1)
    \State $rs \gets borrarRegistro(t,c,d)$             \comment \bigo($L + log(n)$) si c es índice, \bigo($L * n$) sino
    \State
    \If{!esVacio(rs)}                                               \comment \bigo(1)
        \var $r : registro$
        \State $r \gets siguiente(crearIt(rs))$                     \comment \bigo(1)

        \State
        \If{$accesos(siguiente(db.tablaMaxima)) < accesos(t)$}      \comment \bigo(1)
            \State $db.tablaMaxima = obtener(db.tablasTree,nt)$     \comment \bigo(1)
        \EndIf

        \State
        \While{$haySiguiente(it)$}                                  \comment \bigo(1)
            \State                 \icomment El loop se repite $T$ veces
            \var $t' : tabla$
            \State $t' \gets siguiente(it)$                         \comment \bigo(1)
            \If{$nombre(t') \;!= nombre(t)$}                        \comment \bigo($|nombre(t)|$) = \bigo(1)
                \If{$definido?(db.vistasJoin, nombre(t))$}          \comment \bigo($|nombre(t)|$) = \bigo(1)
                    \var $joinsT : diccTrie(nombreTabla, vistaJoin)$
                    \State $joinsT \gets obtener(db.vistasJoin, nombre(t))$                     \comment \bigo($|nombre(t)|$) = \bigo(1)
                    \If{$definido?(joinsT, nombre(t'))$}            \comment \bigo($|nombre(t')|$) = \bigo(1)
                        \var $b : buffer$
                        \State $b \gets obtener(joinsT, nombre(t')).buffer$                     \comment \bigo($|nombre(t')|$) = \bigo(1)
                        \State $agregarAtras(b, <esInsercion: false, tabla: false, reg: r>)$    \comment \bigo($copy(registro)$) = \bigo($L$)
                    \EndIf
                \EndIf
                \State
                \If{$definido?(db.vistasJoin, nombre(t'))$}         \comment \bigo($|nombre(t')|$) = \bigo(1)
                    \var $joinsT' : diccTrie(nombreTabla, vistaJoin)$
                    \State $joinsT' \gets obtener(db.vistasJoin, nombre(t'))$                   \comment \bigo($|nombre(t')|$) = \bigo(1)
                    \If{$definido?(joinsT', nombre(t))$}            \comment \bigo($|nombre(t)|$) = \bigo(1)
                        \var $b : buffer$
                        \State $b \gets obtener(joinsT', nombre(t)).buffer$                     \comment \bigo($|nombre(t)|$) = \bigo(1)
                        \State $agregarAtras(b, <esInsercion: false, tabla: true, reg: r>)$     \comment \bigo($copy(registro)$) = \bigo($L$)
                    \EndIf
                \EndIf
            \EndIf
            \State $avanzar(it)$                                    \comment \bigo(1)
        \EndWhile
    \EndIf
}{Si hay un índice nat: 2 * \bigo(1) + \bigo($L + log(n)$) + 4 * \bigo(1) \\
    \hspace*{16em} + $T$ * (6 * \bigo(1) + \bigo($L$) + 4 * \bigo(1) + \bigo($L$) + \bigo(1)) = \bigo($T * L + log(n)$)
    \hspace*{8.25em} Sino: 2 * \bigo(1) + \bigo($L * n$) + 4 * \bigo(1)
    + $T$ * (6 * \bigo(1) + \bigo($L$) + 4 * \bigo(1) + \bigo($L$) + \bigo(1)) = \bigo($L * (T + n)$)
}

\algoritmo{iGenerarVistaJoin}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$},
    \param{in}{$c$}{$campo$} \\ \hspace*{9.5em}
    }{itConj(registro)}{}{
    \var $firstT_1 : bool$
    \var $t_1, t_2 : tabla$
    \var $pT_a, pT_b : *tabla$
    \var $it : itConj(registro)$
    \var $v : vistaJoin$
    \State $t_1 \gets tabla(db,nt_1)$                               \comment \bigo(1)
    \State $t_2 \gets tabla(db,nt_2)$                               \comment \bigo(1)
    \State $v \gets \; <campo: c, tipo: tipoCampo(t_1,c) \; buffer: vacia(),$ \\
        \hspace*{3em} $joins: vacio(), joinsNat: nuevoDiccLog(), joinString: nuevoTrie()>$      \comment \bigo(1)

    \State
    \If{$(esIndice(t_1, c) \algAnd esIndice(t_2, c) \algAnd cantidadRegistros(t_1) < cantidadRegistros(t_2)) \algOr esIndice(t_2, c)$}
        \State $firstT_1 \gets true$                                \comment \bigo(1)
        \State $pT_a \gets \&t_1$                                   \comment \bigo(1)
        \State $pT_b \gets \&t_2$                                   \comment \bigo(1)
    \Else
        \State $firstT_1 \gets false$                               \comment \bigo(1)
        \State $pT_a \gets \&t_2$                                   \comment \bigo(1)
        \State $pT_b \gets \&t_1$                                   \comment \bigo(1)
    \EndIf
    \State \icomment $t_a$ es $t_1$ si ambas tablas tienen índice en c y $t_1$ tiene la menor cantidad de elementos o solo $t_2$ tiene índice en c
    \Statex \icomment y $t_2$ en otro caso
    \Statex \icomment $t_b$ es la otra tabla

    \State
    \State $it \gets registros(*pT_a)$                              \comment \bigo(1)
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State         \icomment El loop se repite $|registros(t_a)|$ veces
        \var $d : dato$
        \var $rs : conj(registro)$
        \var $r, r_a, r_b : registro$
        \var $it_{reg} : itConj(registro)$
        \State $d \gets significado(r_a, c)$                        \comment \bigo(1)
        \State $rs \gets buscar(*pT_b, c, d)$      \comment \bigo($L + log(|registros(t_b)|)$) si hay un índice sobre $t_b$,
                                                            \bigo($L * |registros(t_b)|$) sino

        \State
        \If{$!esVacio?(rs)$}                                        \comment \bigo(1)
            \State $r_b \gets siguiente(crearIt(rs))$               \comment \bigo(1)

            \State
            \If{$firstT_1$}
                \State $r \gets combinarRegistros(r_a, r_b)$        \comment \bigo(1)
            \Else
                \State $r \gets combinarRegistros(r_b, r_a)$        \comment \bigo(1)
            \EndIf

            \State $it_{reg} \gets agregarRapido(v.joins, r)$       \comment \bigo(1)

            \State
            \If{$v.tipo$}
                \State $definir(v.joinsNat, valorNat(d), it_{reg})$         \comment \bigo($log(n+m) * cmp(nat) + copy(it)$) = \bigo($log(n+m)$)
            \Else
                \State $definir(v.joinsString, valorString(d), it_{reg})$   \comment \bigo($L + copy(it)$) = \bigo($L$)
            \EndIf
        \EndIf

        \State $avanzar(it)$                                        \comment \bigo(1)
    \EndWhile

    \algstore{generarVistaJoin}
}{}
% Cortar para hacer salto de página
\algoritmo{(Continúa) iGenerarVistaJoin}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$},
    \param{in}{$c$}{$campo$} \\ \hspace*{9.5em}
    }{itConj(registro)}
    {\bigo($min(n,m) * (L + log(n + m))$) si el campo es indice de ambas tablas, \\
        \hspace*{8.25em} \bigo($n * (L + log(n + m))$) si el campo es solo índice de $t_2$, \\
        \hspace*{8.25em} \bigo($m * (L + log(n + m))$) si el campo es solo índice de $t_1$ y \\
        \hspace*{8.25em} \bigo($m * (n * L + log(n))$) si el campo no es un índice, \\
        \hspace*{8.25em} donde $n = |registros(t_1)|$ y $m = |registros(t_2)|$}{
    \algrestore{generarVistaJoin}
    \If{$!definido?(db.vistasJoin, nt_1)$}                          \comment \bigo($|nt_1|$) = \bigo(1)
        \State $definir(db.vistasJoin, nt_1, nuevoTrie())$          \comment \bigo($|nt_1|$) = \bigo(1)
    \EndIf
    \State $definir(obtener(db.vistasJoin, nt_1), nt_2, v)$         \comment \bigo($|nt_2|$) = \bigo(1)

    \State $res \gets crearIt(v.joins)$                             \comment \bigo(1)
}{Si c es índice en ambas tablas: $|registros(t_a)|$ = min(n,m) y $|registros(t_b)|$ = max(n,m) $\implies$ \\
    \hspace*{12em} 10 * \bigo(1) + min(n,m) * \\
    \hspace*{14em} (2 * \bigo(1) + \bigo($L + log(max(n,m))$) + 5 * \bigo(1) + \bigo($log(n + m)$) + \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($min(n,m) * (L + log(max(n,m)) + log(n + m))$) = \bigo($min(n,m) * (L + log(n + m))$) \\

    \hspace*{8.25em} Si c es solo índice en $t_2$: $|registros(t_a)|$ = n y $|registros(t_b)|$ = m $\implies$ \\
    \hspace*{12em} 10 * \bigo(1) + n * (2 * \bigo(1) + \bigo($L + log(m)$) + 5 * \bigo(1) + \bigo($log(n + m)$) + \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($n * (L + log(m) + log(n + m))$) = \bigo($n * (L + log(n + m))$) \\

    \hspace*{8.25em} Si c es solo índice en $t_1$: $|registros(t_a)|$ = m y $|registros(t_b)|$ = n $\implies$ \\
    \hspace*{12em} 10 * \bigo(1) + m * (2 * \bigo(1) + \bigo($L + log(n)$) + 5 * \bigo(1) + \bigo($log(n + m)$) + \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($m * (L + log(n) + log(n + m))$) = \bigo($m * (L + log(n + m))$) \\

    \hspace*{8.25em} Si c no es índice: $|registros(t_a)|$ = m y $|registros(t_b)|$ = n $\implies$ \\
    \hspace*{12em} 10 * \bigo(1) + m * (2 * \bigo(1) + \bigo($L * n$) + 5 * \bigo(1) + \bigo($log(n + m)$) + \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($m * (L + L * n + log(n + m))$) = \bigo($m * (n * L + log(n + m))$) \\
}

\algoritmo{iHayTabla}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}
    }{bool}{\bigo(1)}{
    \State $res \gets definido?(db.tablasTree,nt)$                  \comment \bigo($|nt|$) = \bigo(1)
}{}

\algoritmo{iTabla}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}
    }{tabla}{\bigo(1)}{
    \State $res \gets obtener(db.tablasTree,nt)$                    \comment \bigo($|nt|$) = \bigo(1)
}{}

\algoritmo{iTablas}{
    \param{in}{$db$}{$base$}
    }{itConj(tabla)}{\bigo(1)}{
    \State $res \gets crearIt(db.tablas)$                           \comment \bigo(1)
}{}

\algoritmo{iTablaMaxima}{
    \param{in}{$db$}{$base$}
    }{tabla}{\bigo(1)}{
    \State $res \gets siguiente(db.tablaMaxima)$                    \comment \bigo(1)
}{}

\algoritmo{iHayJoin}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}
    }{bool}{\bigo(1)}{
    \State $res \gets definido?(db.vistasJoin,nt_1) \algAnd definido?(obtener(db.vistasJoin,nt_1),nt_2)$
    \Statex                                     \comment \bigo($|nt_1|$) + \bigo($|nt_2|$) = \bigo(1)
}{}

\algoritmo{iCampoJoin}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}
    }{campo}{\bigo(1)}{
    \State $res \gets obtener(obtener(db.vistasJoin,nt_1),nt_2).campo$
                                                \comment \bigo($|nt_1|$) + \bigo($|nt_2|$) = \bigo(1)
}{}

\algoritmo{iBorrarJoin}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}
    }{}{\bigo(1)}{
    \State $borrar(obtener(db.vistasJoin,nt_1),nt_2)$               \comment \bigo($|nt_1|$) + \bigo($|nt_2|$) = \bigo(1)
    \If{$!haySiguiente(crearIt(obtener(db.vistasJoin,nt_1)))$}      \comment \bigo($|nt_1|$) = \bigo(1)
        \State $borrar(db.vistasJoin,nt_1)$                         \comment \bigo($|nt_1|$) = \bigo(1)
    \EndIf
}{3 * \bigo(1) = \bigo(1)}

\algoritmo{iVistaJoin}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}
    }{itConj(registro)}{}{
    \var $v : vistaJoin$
    \var $it : itLista(operacionJoin)$
    \var $t_1, t_2 : tabla$
    \State $v \gets obtener(obtener(db.vistasJoin,nt_1),nt_2)$      \comment \bigo($|nt_1|$) + \bigo($|nt_2|$) = \bigo(1)
    \State $t_1 \gets tabla(db,nt_1)$                               \comment \bigo(1)
    \State $t_2 \gets tabla(db,nt_2)$                               \comment \bigo(1)

    \State
    \State $it \gets crearIt(v.buffer)$                             \comment \bigo(1)
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State         \icomment El loop se repite $R$ veces
        \var $op : operacionJoin$
        \var $d : dato$
        \State $op \gets siguiente(it)$                             \comment \bigo(1)
        \State $d \gets obtener(op.reg, v.campo)$                   \comment \bigo(1)

        \If{$op.esInsercion$}
            \var $rs : conj(registro)$
            \var $r, r_b : registro$
            \If{$!op.enTablaB$}                                     \comment \bigo(1)
                \State $rs \gets buscar(t_2, v.campo, d)$           \comment \bigo($L + log(m)$) si es índice, \bigo($L * m$) sino
            \Else
                \State $rs \gets buscar(t_1, v.campo, d)$           \comment \bigo($L + log(n)$) si es índice, \bigo($L * n$) sino
            \EndIf
            \If{$!esVacio?(rs)$}                                    \comment \bigo(1)
                \State $r_b \gets siguiente(crearIt(rs))$           \comment \bigo(1)

                \State
                \If{$!op.enTablaB$}                                 \comment \bigo(1)
                    \State $r \gets combinarRegistros(op.reg, r_b)$ \comment \bigo(1)
                \Else
                    \State $r \gets combinarRegistros(r_b, op.reg)$ \comment \bigo(1)
                \EndIf

                \State
                \State $it_{reg} \gets agregarRapido(v.joins, r)$   \comment \bigo($copy(registro)$) = \bigo(1)
                \If{$v.tipo$}
                    \State $definirRapido(v.joinsNat, valorNat(d), it_{reg})$           \comment \bigo($copy(it)$) = \bigo(1)
                \Else
                    \State $definirRapido(v.joinsString, valorString(d), it_{reg})$     \comment \bigo($copy(it)$) = \bigo(1)
                \EndIf
            \EndIf
        \Else
            \If{$v.tipo$}                                           \comment \bigo(1)
                \If{$definido?(v.joinsNat, valorNat(d))$}           \comment \bigo($log(min(n,m)) * cmp(nat)$) = \bigo($log(min(n,m))$)
                    \State $eliminarSiguiente(obtener(v.joinsNat, valorNat(d)))$
                    \Statex                                         \comment \bigo($log(min(n,m)) * cmp(nat)$) = \bigo($log(min(n,m))$)
                    \State $borrar(v.joinsNat, valorNat(d))$        \comment \bigo($log(min(n,m)) * cmp(nat)$) = \bigo($log(min(n,m))$)
                \EndIf
            \Else
                \If{$definido?(v.joinsString, valorString(d))$}     \comment \bigo($L$)
                    \State $eliminarSiguiente(obtener(v.joinsString, valorString(d)))$  \comment \bigo($L$)
                    \State $borrar(v.joinsString, valorString(d))$  \comment \bigo($L$)
                \EndIf
            \EndIf
        \EndIf

        \State $avanzar(it)$                                        \comment \bigo(1)
    \EndWhile
    \State $res \gets crearIt(v.joins)$                             \comment \bigo(1)
    \algstore{vistaJoin}
}{}
% pagebreak
\algoritmo{(Continúa) iVistaJoin}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}
    }{itConj(registro)}{
        \bigo(1) si $R = 0$, \\
        \hspace*{8.25em} \bigo($R * (L + log(n * m))$) si $R > 0$ y ambas tablas tienen índice en el campo del join y \\
        \hspace*{8.25em} \bigo($R * L * (n + m)$) sino \\
        \hspace*{8.25em} R es la cantidad de modificaciónes sobre las tablas desde la generación o última visualización del join}{
    \algrestore{vistaJoin}
    \State
}{Si $R = 0$: 6 * \bigo(1) = \bigo(1) \\

    \hspace*{8.25em} Si $R > 0$ y el campo es índice en ambas tablas: 4 * \bigo(1) + R * (4 * \bigo(1) + \bigo($L + log(m)$) \\
    \hspace*{12em} + \bigo($L + log(n)$) + 9 * \bigo(1) + 3 * \bigo($log(min(n,m))$) + 3 * \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($R * (L + log(m) + log(n) + log(min(n,m)))$) = \bigo($R * (L + log(m) + log(n))$) \\
    \hspace*{12em} = \bigo($R * (L + log(m * n))$) \\

    \hspace*{8.25em} Si $R > 0$ y el campo no es índice en ambas tablas: 4 * \bigo(1) + R * (4 * \bigo(1) + \bigo($L * m$) \\
    \hspace*{12em} + \bigo($L * n$) + 9 * \bigo(1) + 3 * \bigo($log(min(n,m))$) + 3 * \bigo($L$) + \bigo(1)) \\
    \hspace*{12em} = \bigo($R * (L * m + L * n + log(min(n,m)) + L)$) = \bigo($R * (L * (n+m) + log(n+m))$) \\
    \hspace*{12em} = \bigo($R * L * (n + m)$)
}

\algoritmo{iBuscar}{
    \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}
}{conj(registro)}
{\bigo($in$), donde $in$ = \\
    \hspace*{4em} \bigo($L$) si hay un campo clave e índice string como criterio, \\
    \hspace*{4em} \bigo($L + log(n)$) si hay un campo clave e índice nat, \\
    \hspace*{4em} \bigo($L * n$) si no, \\
    \hspace*{4em} donde $n = |registros(dameTabla(nt,db)|)$}{

    \State $res \gets buscar(tabla(db,nt),r)$   \comment \bigo($in$)
}{}


\subsubsection{Funciones auxiliares de los algoritmos}

\operacion{CombinarRegistros}
{   \param{in}{$r_1$}{$registro$},
    \param{in}{$r_2$}{$registro$}}
{registro}
{true}
{$res \igobs agregarCampos(r_1, r_2)$}
{\bigo(1)}
{}
{La complejidad es constante pues la cantidad de campos está acotada}

\algoritmo{iCombinarRegistros}{
    \param{in}{$r_1$}{$registro$},
    \param{in}{$r_2$}{$registro$}
    }{registro}{\bigo(1)}{
    \var $it : itDiccLog(campo,dato)$
    \State $res \gets vacio()$                                      \comment \bigo(1)

    \State
    \State $it \gets crearIt(r_2)$                                  \comment \bigo(1)
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State \icomment El loop se ejecuta $|campos(r_2)|$ veces, acotado por constante
        \State $definir(res, siguiente(it).clave, siguiente(it).significado)$
                                        \comment \bigo($log(|campos(r_2)|)$) = \bigo(1)
    \EndWhile

    \State
    \State \icomment Siguiendo la especificación, los valores de $r_1$ pisan los repetidos de $r_2$
    \State $it \gets crearIt(r_1)$                                  \comment \bigo(1)
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State \icomment El loop se ejecuta $|campos(r_1)|$ veces, acotado por constante
        \State $definir(res, siguiente(it).clave, siguiente(it).significado)$
                                        \comment \bigo($log(|campos(r_2)| + |campos(r_1)|)$) = \bigo(1)
    \EndWhile
}{2 * \bigo(1) + $k_2$ * 2 * \bigo(1) + \bigo(1) + $k_1$ * 2 * \bigo(1) = \bigo(1)}

\subsection{Servicios usados}

\usaServicio{Dato}
\usaServicio{Tabla}
\usaServicio{DiccLog}
\usaServicio{DiccTrie}
\usaServicio{Conjunto Lineal ($\alpha$)}
\usaServicio{Lista Enlazada ($\alpha$)}

