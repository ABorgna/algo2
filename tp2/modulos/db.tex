\section{BaseDeDatos}

\subsection{Interfaz}

\iusa{}
\iseexplica{BaseDeDatos}
\igenero{db}

\ioperaciones

\begin{itemize}
    \item{$T$ es la cantidad de tablas en la db}
    \item{$n$ y $m$ son la cantidad de registros presentes en las tablas sobre las que se opera}
    \item{$L$ es el máximo largo de un dato string}
    \item{La cantidad de campos se asume acotada por constante}
    \item{Los nombres de tablas y campos se asumen acotados por constante}
\end{itemize}

\operacion{NuevaDB}
{} % parametros
{base} % tipo res
{} % pre
{$res \igobs nuevaDB()$} % post
{\bigo(1)} % complejidad
{} % aliasing
{} % descripcion

\operacion{AgregarTabla}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$t$}{$tabla$}}
{}
{$db \igobs db_0 \land \emptyset?(registros(t)) \land \neg(nombre(t) \in tablas(db))$}
{$db \igobs agregarTabla(t,db_0)$}
{\bigo(1)}
{No se debe modificar la tabla después de insertada}
{}

\operacion{InsertarEntrada}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}}
{}
{$db \igobs db_0 \land nt \in tablas(db) \land_L puedoInsertar?(r,dameTabla(nt,db))$}
{$db \igobs insertarEntrada(t,db_0)$}
{\bigo($T * L + in$)}
{}
{$in$ es \bigo($log(n)$) si hay un índice sobre un campo de tipo NAT, \bigo(1) sino}

\operacion{Borrar}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{}
{$db \igobs db_0 \land nt \in tablas(db) \land c \in claves(dameTabla(nt,db)) \land_L \\
    \hspace*{4em} tipo?(d) \igobs tipoCampo(c,dameTabla(nt,db))$}
{$db \igobs borrar(definir(c,d,vacio),db_0)$}
{\bigo($T * L + in$) \cuidado piden esta complejidad, pero seria $L * in$ si comparamos las strings}
{}
{$in$ es \bigo($log(n)$) si el campo de borrado es un índice, \bigo($n$) sino}

\operacion{GenerarVistaJoin}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$}, \\ \hspace*{9.6em}
    \param{in}{$nt_2$}{$nombreTabla$},
    \param{in}{$c$}{$campo$}}
{itDiccLog(dato,registro)}
{$db \igobs db_0 \land nt_2 \in tablas(db) \land nt_1 \in tablas(db) \land nt_1 \neq nt_2 \land_L \\
    \hspace*{4em} c \in claves(dameTabla(nt_1,db)) \land c \in claves(dameTabla(nt_2,db)) \land_L \\
    \hspace*{4em} tipoCampo(c,dameTabla(nt_1,db)) \igobs tipoCampo(c,dameTabla(nt_2,db)) \land \\
    \hspace*{4em} \neg hayJoin?(nt_1,nt_2,db)$}
{$db \igobs generarVistaJoin(nt_1,nt_2,c,db_0) \land \neg hayAnterion(res) \land haySiguiente(res)$ \cuidado que onda el iterador?}
{$in$}
{}
{$in$ es \bigo($min(n,m) * (L + log(n + m))$) si el campo es indice de ambas tablas, \\
    \hspace*{4em} \bigo($n * (L + log(n + m))$) si el campo es sólo índice de $t_1$, \\
    \hspace*{4em} \bigo($m * (L + log(n + m))$) si el campo es sólo índice de $t_2$ y \\
    \hspace*{4em} \bigo($n * (m + L + log(n))$) si el campo no es un índice, \\
    \hspace*{4em} donde $n = |registros(t_1)|$ y $m = |registros(t_2)|$}

\operacion{HayTabla}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}}
{$bool$}
{$true$}
{$res \igobs nt \in tablas(db)$}
{\bigo(1)}
{}
{}

\operacion{Tabla}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$}}
{$tabla$}
{$nt \in tablas(db)$}
{$res \igobs dameTabla(nt,db)$}
{\bigo(1)}
{No se debe modificar la tabla devuelta}
{}

\operacion{Tablas}
{   \param{in}{$db$}{$base$}}
{$itConj(tabla)$}
{true}
{$haySiguient(res) \land \neg hayAnterior(res)$ \cuidado cómo decimos que recorre todas las tablas?}
{\bigo(1)}
{No se debe modificar las tablas}
{El iterador devuelto tiene $siguiente()$ en \bigo(1)}

\operacion{TablaMaxima}
{   \param{in}{$db$}{$base$}}
{$tabla$}
{$\#tablas(db) > 0$}
{$res \igobs dameTabla(tablaMaxima(db),db)$}
{\bigo(1)}
{No se debe modificar la tabla devuelta}
{}

\operacion{HayJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$bool$}
{$true$}
{$res \igobs hayJoin?(nt_1,nt_2,db)$}
{\bigo(1)}
{}
{}

\operacion{CampoJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$campo$}
{$hayJoin?(nt_1,nt_2,db)$}
{$res \igobs campoJoin(nt_1,nt_2,db)$}
{\bigo(1)}
{}
{}

\operacion{BorrarJoin}
{   \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{}
{$db \igobs db_0 \land hayJoin?(nt_1,nt_2,db)$}
{$db \igobs borrar(nt_1,nt_2,db_0)$}
{\bigo($n + m$)}
{}
{}

\operacion{VistaJoin}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$}}
{$itDiccLog(dato,registro)$}
{$hayJoin?(nt_1,nt_2,db)$}
{$\neg hayAnterior(res) \land haySiguiente(res)$ \cuidado el mismo tema, cómo vemos que res es válido?}
{\bigo($in$)}
{No se debe modificar los resultados}
{$in$ es \bigo($R * (L + log(n * m))$) donde R es la cantidad de modificaciónes desde la generación \\
    \hspace*{4em} o última visualización del join, u \bigo(1) si $R = 0$}

\operacion{Buscar}
{   \param{in}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}}
{$conj(registro)$}
{$nt \in tablas(db) \land_L c \in campos(dameTabla(nt,db)) \land_L tipo?(d) \igobs tipoCampo(dameTabla(nt,db))$}
{$res \igobs buscar(definir(c,d,vacio), nt, db)$}
{\bigo($in$)}
{No se debe modificar los resultados}
{$in$ es \bigo($R * (L + log(n * m))$) donde R es la cantidad de modificaciónes desde la generación \\
    \hspace*{4em} o última visualización del join, u \bigo(1) si $R = 0$}

\subsection{Representación}

-- todo: explicacion --

\serepresenta{db}{vec}
\donde{vec}{tupla($tablas$: tablas, $tablasTree$: tablasTree, $vistasJoin$: vistas, $tablaMaxima$: maxima)}
\donde{tablas}{conj($tabla$)}
\donde{tablasTree}{diccTrie($nombreTabla$, itConj($tabla$))}
\donde{maxima}{puntero($tabla$)}
\donde{vistas}{diccTrie($nombreTabla$, diccTrie($nombreTabla$, $vistaJoin$))}
\donde{vistaJoin}{tupla($campo$: campo, $tipo$: bool, $buffer$: buffer, \\
    $joins$: joins, $joinsNat$: jNat, $joinsString$: jString)}
\donde{joins}{conj($registro$)}
\donde{joinsNat}{diccLog($nat, itConj(registro)$)}
\donde{joinsString}{diccTrie($itConj(registro)$)}
\donde{buffer}{lista($operacionJoin$)}
\donde{operacionJoin}{tupla($esInsercion$: bool, $tabla$: bool, $reg$: $registro$)}

\donde{nombreTabla}{string}
\donde{campo}{string}
\donde{registro}{diccLog($campo$,$dato$)}

\subsubsection{Invariante de representación}

\begin{Rep}{$estr$}{$e$}
    \repfunc{tablasTree tiene las tablas}
        {\#e.tablas = \#claves(e.tablasTree) \land \\
        (\forall t : tabla) (t \in e.tablas \implies def?(nombre(t), e.tablasTree) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(nombre(t), e.tablasTree)) \land_L \\
        \hspace*{10em} Siguiente(obtener(nombre(t, e.tablasTree)) \igobs t))}

    \repfunc{vistasJoin tiene tablas válidas}
        {(\forall nt : nombreTabla) (def?(nt, e.vistasJoin) \implies \\
        \hspace*{4em} def?(nt, e.tablasTree) \land_L \\
        \hspace*{4em} (\forall nt' : nombreTabla) (def?(nt', obtener(nt,e.vistasJoin)) \implies \\
        \hspace*{8em} def?(nt', e.tablasTree))}

    \repfunc{El campo de las vistasJoin es válido}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\ \\
        \hspace*{6em} v.campo \in claves(t_a) \land \\
        \hspace*{6em} v.campo \in claves(t_b) \land_L \\
        \hspace*{6em} tipoCampo(v.campo, t_a) \igobs tipoCampo(v.campo, t_b) \land \\
        \hspace*{6em} v.tipo \igobs tipoCampo(v.campo, t_b) }

    \repfunc{Los registros de cada buffer tienen los campos de las tablas correspondientes}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op : operacionJoin) \; op \in v.buffer \implies \\
        \hspace*{8em} \IFLM \neg op.tabla THEN \\
        \hspace*{10em} campos(op.reg) \igobs campos(t_a) \land_L mismosTipos(op.reg, t_a) \\
        \hspace*{8em} ELSE \\
        \hspace*{10em} campos(op.reg) \igobs campos(t_b) \land_L mismosTipos(op.reg, t_b) \\
        \hspace*{8em} FI
    }

    \repfunc{Los joins cacheados tienen los campos de ambas tablas}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) \; r \in v.joins \implies (\\
        \hspace*{10em} campos(r) \igobs campos(t_a) \cup campos(t_b) \land \\
        \hspace*{10em} (\forall c : campo) \; c \in campos(r) \implies (\\
        \hspace*{12em} (c \in campos(t_a) \land_L tipoCampo(c,t_a) \igobs tipo?(obtener(c,r))) \lor \\
        \hspace*{12em} (c \in campos(t_b) \land_L tipoCampo(c,t_b) \igobs tipo?(obtener(c,r)))))
    }

    \repfunc{Los diccionarios de índices de los joins tienen todas las entradas}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} \IFLM v.tipo THEN \\
        \hspace*{8em} \#v.joins \igobs \#claves(v.joinsNat) \land \\
        \hspace*{8em} (\forall r : registro) \; r \in v.joins \implies \\
        \hspace*{10em} def?(valorNat(obtener(v.campo, r)), v.joinsNat) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(valorNat(obtener(v.campo, r)), v.joinsNat)) \land_L \\
        \hspace*{10em} siguiente(obtener(valorNat(obtener(v.campo, r)), v.joinsNat)) \igobs r \\
        \hspace*{6em} ELSE \\
        \hspace*{8em} \#v.joins \igobs \#claves(v.joinsString) \land \\
        \hspace*{8em} (\forall r : registro) \; r \in v.joins \implies \\
        \hspace*{10em} def?(valorString(obtener(v.campo, r)), v.joinsString) \land_L \\
        \hspace*{10em} haySiguiente?(obtener(valorString(obtener(v.campo, r)), v.joinsString)) \land_L \\
        \hspace*{10em} siguiente(obtener(valorString(obtener(v.campo, r)), v.joinsString)) \igobs r \\
        \hspace*{6em} FI
    }

    \repfunc{No hay dos inserciones seguidas en un buffer (sin borrar antes)}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op, op' : operacionJoin) \; (op \in v.buffer \; \land \; op' \in v.buffer \; \land_L \\
        \hspace*{10em} op.esInsercion \; \land \; op'.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg)) \implies \\
        \hspace*{8em} (\exists op'' : operacionJoin) \; (op'' \in v.buffer \; \land_L \\
        \hspace*{10em} \neg op''.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg) \; \land \\
        \hspace*{10em} estaDespues?(op'', op, v.buffer) \; \land \\
        \hspace*{10em} estaDespues?(op', op'', v.buffer))
    }

    \repfunc{No hay inserciones de indices ya cacheados en un buffer (sin borrar antes)}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall d : dato) \; (\forall op : operacionJoin) \; (op \in v.buffer \; \land \; op.esInsercion \land \\
        \hspace*{10em} datoIndexado?(d,v.joinsNat,v.joinsString) \; \land_L obtener(v.campo, op.reg) \igobs d ) \implies \\
        \hspace*{8em} (\exists op' : operacionJoin) \; (op' \in v.buffer \; \land_L \neg op'.esInsercion \; \land \\
        \hspace*{10em} obtener(v.campo,op'.reg) \igobs d \; \land  estaDespues?(op', op, v.buffer))
    }

    \repfunc{Todos los joins posibles están cacheados en vistasJoins y no hay modificaciones en el buffer, o la inserción está en el buffer y no se la borra luego}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) r \in combinarRegistros(v.campo, registros(t_a), registros(t_b)) \implies_L (\\
        \hspace*{8em} (r \in v.joins \land \\
        \hspace*{10em} \neg(\exists op' : operacionJoin) \; (op' \in v.buffer \; \land \\
        \hspace*{12em} obtener(v.campo,r) \igobs obtener(v.campo, op'.reg))) \lor \\
        \hspace*{8em} ((\exists op : operacionJoin) \; op \in v.buffer \; \land \; op.esInsercion \; \land_L \\
        \hspace*{10em} coincidenTodos(r, campos(op.reg), op.reg) \land \\
        \hspace*{10em} \neg(\exists op' : operacionJoin) \; (op' \in v.buffer \; \land \\
        \hspace*{12em} obtener(v.campo,r) \igobs obtener(v.campo,op'.reg) \land \\
        \hspace*{12em} estaDespues?(op', op, v.buffer))))}

    \repfunc{vistasJoins tiene joins válidos o joins que seran eliminados}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall r : registro) \; r \in v.joins \implies_L (\\
        \hspace*{10em} r \in combinarRegistros(v.campo, registros(t_a), registros(t_b))\\
        \hspace*{8em}  \lor \\
        \hspace*{8em} ((\exists op : operacionJoin) \; op \in v.buffer \; \land_L \\
        \hspace*{10em} obtener(v.campo,r) \igobs obtener(v.campo,op.reg)))}

    \repfunc{Si hay inserciones de joins no válidos en el buffer, también está su eliminación}
        {(\forall nt,nt' : nombreTabla) def?(nt,e.vistasJoin) \land_L def?(nt', obtener(nt,e.vistasJoin)) \implies_L \\
        \hspace*{4em} (\exists v : vistaJoin) \; (\exists t_a, t_b : tabla) \\
        \hspace*{6em} v \igobs obtener(nt',obtener(nt,e.vistasJoin)) \land \\
        \hspace*{6em} t_a \igobs obtener(nt, e.tablasTree) \land t_b \igobs obtener(nt', e.tablasTree) \land \\
        \\
        \hspace*{6em} (\forall op : operacionJoin) \; (op \in v.buffer \land op.esInsercion \land \\
        \hspace*{16em} \emptyset?(coincidencias(op.reg, \\
        \hspace*{18em} combinarRegistros(v.campo, registros(t_a), \\
        \hspace*{20em} registros(t_b))))) \implies \\
        \hspace*{8em} ((\exists op' : operacionJoin) \; op' \in v.buffer \; \land \\
        \hspace*{10em} obtener(v.campo,op.reg) \igobs obtener(v.campo,op'.reg) \; \land \\
        \hspace*{10em} estaDespues?(op', op, v.buffer))}

    \repfunc{Si hay tablas, e.tablaMaxima apunta a una de las tablas con mas cantidadDeAccesos}{}

\end{Rep}

\subsubsection{Operaciones auxiliares del invariante de representación}

\tadOperacion{estaDespues?}{$\alpha$/a, $\alpha$/b, secu($\alpha$)}{bool}{esta?(a,s) $\land$ esta?(b,s)}
\tadOperacion{datoIndexado?}{d/dato, dicc(nat\,$\alpha$)/dn, dicc(string\,$\beta$)/ds}{bool}{}

\tadAxiomas[\paratodo{secu($\alpha$)}{s}, \paratodo{$\alpha$}{a,b}]

\tadAxioma{estaDespues?(a,b,s)}{$\neg$(prim(s) $=$ a) $\land_L$ (prim(s) $=$ b $\lor_L$ estaDespues?(a,b,fin(s)))}
\tadAxioma{datoIndexado?(d,dn,ds)}{\IF Nat?(d) THEN valorNat(d) $\in$ claves(dn) ELSE valorString(d) $\in$ claves(ds) FI}

\subsubsection{Función de abstracción}

\begin{ABS}{$e$}{$estr$}{$db$}{$base$}
    \absfunc{}{tablas(db) \igobs claves(e.tablasTree) \; \land_L }
    \absfunc{}{(\forall t : tabla) \: t \in e.tablas \implies_L \; dameTabla(nombre(t), db) \igobs t \; \land}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) \: nt \in tablas(db) \land nt' \in tablas(db) \implies \\
        \hspace*{4em} (hayJoin?(nt, nt', db) \iff def?(nt, e.vistasJoin) \;\land_L\; def?(nt', obtener(nt, e.vistasJoin))) \; \land_L}
    \absfunc{}
        {(\forall nt, nt' : nombreTabla) hayJoin?(nt, nt', db) \implies \\
        \hspace*{4em} obtener(nt', obtener(nt, e.vistasJoin)).campo \igobs campoJoin(nt, nt', db)}
\end{ABS}

\subsection{Algoritmos}

\algoritmo{iNuevaDB}{}{base}{\bigo(1)}{
    \State $res.tablas \gets vacio()$                               \comment \bigo(1)
    \State $res.tablasTree \gets nuevoDiccLog()$                    \comment \bigo(1)
    \State $res.vistasJoin \gets nuevoTrie()$                       \comment \bigo(1)
    \State $res.tablaMaxima \gets NULL$                             \comment \bigo(1)
}

\algoritmo{iAgregarTabla}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$t$}{$tabla$}
    }{}{\bigo(1)}{
    \var $it : itConj(tabla)$
    \State $it \gets agregarRapido(db.tablas, t)$                   \comment \bigo(1)
    \State $definir(res.tablasTree, nombre(t), it)$                 \comment \bigo(1)
    \If{$db.tablaMaxima == NULL$}                                   \comment \bigo(1)
        \State $db.tablaMaxima = \&t$                               \comment \bigo(1)
    \EndIf
}

\algoritmo{iInsertarEntrada}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$r$}{$registro$}
    }{}{\bigo($T * L + in$)}{
    \var $t : tabla$
    \var $it : itConj(tabla)$
    \State $t \gets tabla(db,nt)$                                   \comment \bigo(1)
    \State $it \gets tablas(db)$                                    \comment \bigo(1)
    \State $agregarRegistro(t,r)$                                   \comment \bigo($L + in$)
    \If{$accesos(*db.tablaMaxima) < accesos(t)$}                    \comment \bigo(1)
        \State $db.tablaMaxima = \&t$                               \comment \bigo(1)
    \EndIf
    \State
    \While{$haySiguiente(it)$}                                      \comment \bigo(1)
        \State                 \icomment El loop se repite $T$ veces
        \var $t' : tabla$
        \State $t' \gets siguiente(it)$                             \comment \bigo(1)
        \If{$nombre(t') \;!= nombre(t)$}                            \comment \bigo(1)
            \If{$definido?(db.vistasJoin, nombre(t))$}              \comment \bigo(1)
                \var $joinsT : diccTrie(nombreTabla, vistaJoin)$
                \State $joinsT \gets obtener(db.vistasJoin, nombre(t))$                 \comment \bigo(1)
                \If{$definido?(joinsT, nombre(t'))$}                \comment \bigo(1)
                    \var $b : buffer$
                    \State $b \gets obtener(joinsT, nombre(t')).buffer$                 \comment \bigo(1)
                    \State $agregarAtras(b, <esInsercion: true, tabla: false, reg: r>)$ \comment \bigo($L$)
                \EndIf
            \EndIf
            \State
            \If{$definido?(db.vistasJoin, nombre(t'))$}             \comment \bigo(1)
                \var $joinsT' : diccTrie(nombreTabla, vistaJoin)$
                \State $joinsT' \gets obtener(db.vistasJoin, nombre(t'))$               \comment \bigo(1)
                \If{$definido?(joinsT', nombre(t))$}                \comment \bigo(1)
                    \var $b : buffer$
                    \State $b \gets obtener(joinsT', nombre(t)).buffer$                 \comment \bigo(1)
                    \State $agregarAtras(b, <esInsercion: true, tabla: true, reg: r>)$  \comment \bigo($L$)
                \EndIf
            \EndIf
        \EndIf
        \State $avanzar(it)$                                        \comment \bigo(1)
    \EndWhile
}

\algoritmo{iBorrar}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt$}{$nombreTabla$},
    \param{in}{$c$}{$campo$},
    \param{in}{$d$}{$dato$}
    }{}{\bigo($T * L + in$)}{
    \var $t : tabla$
    \var $it : itConj(tabla)$
    \var $rs : conj(registro)$
    \State $t \gets tabla(db,nt)$                                   \comment \bigo(1)
    \State $it \gets tablas(db)$                                    \comment \bigo(1)
    \State $rs \gets borrarRegistro(t,c,d)$                         \comment \bigo($L + in$)
    \State
    \If{!esVacio(rs)}
        \var $r : registro$
        \State $r \gets siguiente(crearIt(rs))$                     \comment \bigo(1)

        \State
        \If{$accesos(*db.tablaMaxima) < accesos(t)$}                \comment \bigo(1)
            \State $db.tablaMaxima = \&t$                           \comment \bigo(1)
        \EndIf

        \State
        \While{$haySiguiente(it)$}                                  \comment \bigo(1)
            \State                 \icomment El loop se repite $T$ veces
            \var $t' : tabla$
            \State $t' \gets siguiente(it)$                         \comment \bigo(1)
            \If{$nombre(t') \;!= nombre(t)$}                        \comment \bigo(1)
                \If{$definido?(db.vistasJoin, nombre(t))$}          \comment \bigo(1)
                    \var $joinsT : diccTrie(nombreTabla, vistaJoin)$
                    \State $joinsT \gets obtener(db.vistasJoin, nombre(t))$                     \comment \bigo(1)
                    \If{$definido?(joinsT, nombre(t'))$}            \comment \bigo(1)
                        \var $b : buffer$
                        \State $b \gets obtener(joinsT, nombre(t')).buffer$                     \comment \bigo(1)
                        \State $agregarAtras(b, <esInsercion: false, tabla: false, reg: r>)$    \comment \bigo($L$)
                    \EndIf
                \EndIf
                \State
                \If{$definido?(db.vistasJoin, nombre(t'))$}         \comment \bigo(1)
                    \var $joinsT' : diccTrie(nombreTabla, vistaJoin)$
                    \State $joinsT' \gets obtener(db.vistasJoin, nombre(t'))$                   \comment \bigo(1)
                    \If{$definido?(joinsT', nombre(t))$}            \comment \bigo(1)
                        \var $b : buffer$
                        \State $b \gets obtener(joinsT', nombre(t)).buffer$                     \comment \bigo(1)
                        \State $agregarAtras(b, <esInsercion: false, tabla: true, reg: r>)$     \comment \bigo($L$)
                    \EndIf
                \EndIf
            \EndIf
            \State $avanzar(it)$                                    \comment \bigo(1)
        \EndWhile
    \EndIf
}

\algoritmo{iGenerarVistaJoin}{
    \param{in/out}{$db$}{$base$},
    \param{in}{$nt_1$}{$nombreTabla$},
    \param{in}{$nt_2$}{$nombreTabla$},
    \param{in}{$c$}{$campo$} \\ \hspace*{9.5em}
    }{itDiccLog(dato,registro)}{\bigo($in$)}{
    \var $t_1, t_2 : tabla$
    \var $it : itConj(tabla)$
    \var $v : vistaJoin$
    \State $t_1 \gets tabla(db,nt_1)$                               \comment \bigo(1)
    \State $t_2 \gets tabla(db,nt_2)$                               \comment \bigo(1)
    \State $v \gets \; <campo: c, \; buffer: vacia(), \; joins: nuevoDiccLog()>$

    \State
    \If{$(esIndice(t_1, c) \algAnd esIndice(t_2, c) \algAnd cantidadRegistros(t_1) < cantidadRegistros(t_2)) \algOr $\\
    \hspace*{8em} $esIndice(t_2, c)$}
        \State $it \gets registros$
    \ElsIf{$(esIndice(t_1, c) \algAnd esIndice(t_2, c) \algAnd cantidadRegistros(t_1) > cantidadRegistros(t_2)) \algOr $\\
    \hspace*{8em} $esIndice(t_1, c)$}
    \Else
    \EndIf

    \State
    \If{$!definido?(db.vistasJoin, nt_1)$}                          \comment \bigo(1)
        \State $definir(db.vistasJoin, nt_1, nuevoTrie())$
    \EndIf
    \State $definir(obtener(db.vistasJoin, nt_1), nt_2, v)$
}

\subsection{Servicios usados}

