\section{diccLog($\kappa, \alpha$)}

El módulo diccLog provee un diccionario con acceso, inserción y borrado en \bigo(log($n$)), donde $n$ es la cantidad de elementos actuales.

\subsection{Interfaz}

\begin{iparamformales}{$\kappa, \alpha$}

    \funcion{$\bullet = \bullet$} % Nombre
        {\param{in}{$k_0$}{$\kappa$}, \param{in}{$k_1$}{$\kappa$}} % Parametros
        {bool} % Tipo resultado
        {true} % Pre
        {res \igobs ($k_0 = k_1$)} % Post
        {$\Theta(equal(k_0, k_1))$} % Complejidad
        {} % Aliasing
        {Función de igualdad de $\kappa$'s} % Descripcion

    \funcion{$\bullet > \bullet$} % Nombre
        {\param{in}{$k_0$}{$\kappa$}, \param{in}{$k_1$}{$\kappa$}} % Parametros
        {bool} % Tipo resultado
        {true} % Pre
        {res \igobs ($k_0 > k_1$)} % Post
        {$\Theta(greater(k_0, k_1))$} % Complejidad
        {} % Aliasing
        {Función orden estricto de $\kappa$'s} % Descripcion

    \funcion{Copiar}
        {\param{in}{$k$}{$\kappa$}}
        {$\kappa$}
        {true}
        {$res \igobs k$}
        {\bigo($copy(k)$)}
        {}
        {Funcion de copia de $\kappa$'s}


\end{iparamformales}

\iusa{}
\iseexplica{Diccionario($\kappa, \alpha$), Iterador Unidireccional Modificable( tupla($\kappa, \alpha$) )}
\igenero{diccLog($\kappa, \alpha$), itDiccLog($\kappa, \alpha$)}

\ioperaciones

\operacion{NuevoDiccLog}
{}
{diccLog($\kappa, \alpha$)}
{true}
{$res \igobs vacio$}
{\bigo(1)}
{}
{Crea un diccionario vacio}

\operacion{Definir}
{   \param{in/out}{$d$}{diccLog($\kappa, \alpha$)},
    \param{in}{$c$}{$\kappa$},
    \param{in}{$v$}{$\alpha$}}
{}
{$d \igobs d_0$}
{$d \igobs definir(c, v, d_0)$}
{\bigo($log(n)cmp + copy(c)$), donde $n = \#(claves(d))$ y $cmp = equal(c, c')+greater(c, c')$}
{alias($obtener(c, d) = v$), hasta que se redefina o se borre la clave}
{Modifica el diccionario agregando o reemplazando el significado de una clave 
    con un nuevo valor}

\operacion{Definido?}
{   \param{in}{$d$}{diccLog($\kappa, \alpha$)},
    \param{in}{$c$}{$\kappa$}}
{bool}
{true}
{$res \igobs def?(c, d)$}
{\bigo($log(n)cmp$), donde $n = \#(claves(d))$ y $cmp = equal(c, c')+greater(c, c')$}
{}
{Devuelve true si una clave se encuentra definida en el diccionario}

\operacion{Obtener}
{   \param{in}{$d$}{diccLog($\kappa, \alpha$)},
    \param{in}{$c$}{$\kappa$}}
{$\alpha$}
{$def?(c, d)$}
{$res$ \igobs $obtener(c, d)$}
{\bigo($log(n)cmp$), donde $n = \#(claves(d))$ y $cmp = equal(c, c')+greater(c, c')$}
{}
{Devuelve el significado definido para la clave $c$}

\operacion{Borrar}
{   \param{in/out}{$d$}{diccLog($\kappa, \alpha$)},
    \param{in}{$c$}{$\kappa$}}
{}
{$d \igobs d_0 \land def?(c, d)$}
{$d \igobs borrar(c, d_0)$}
{\bigo($log(n)cmp$), donde $n = \#(claves(d))$ y $cmp = equal(c, c')+greater(c, c')$}
{}
{Borra el significado asociado a la clave $c$}


\cuidado Definir funcion auxiliar maximo y minimo sobre claves del diccionario

\operacion{Maximo}
{   \param{in}{$d$}{diccLog($\kappa, \alpha$)}}
{itDiccLog($\kappa, \alpha$)}
{$\neg (d \igobs vacio)$}
{$siguiente(res) \igobs tupla(maximo(d), obtener(maximo(d)))$}
{\bigo(1)}
{}
{Obtiene un iterador a la clave y el significado del elemento con la clave 
    mas grande en el diccionario}

\operacion{Minimo}
{   \param{in}{$d$}{diccLog($\kappa, \alpha$)}}
{itDiccLog($\kappa, \alpha$)}
{$\neg (d \igobs vacio)$}
{$siguiente(res) \igobs tupla(minimo(d), obtener(minimo(d)))$}
{\bigo(1)}
{}
{Obtiene un iterador a la clave y el significado del elemento con la clave 
    mas pequeña en el diccionario}



\subsubsection{Operaciones del iterador}

\operacion{CrearIt}
{   \param{in}{$d$}{diccLog($\kappa, \alpha$)}}
{itDiccLog($\kappa, \alpha$)}
{true}
{$res \igobs crearItMod(<>, listaDeTupas(d))$ $\land$ alias($SecuSuby(res) = listaDeTuplas(d)$)}
{\bigo(1)}
{\cuidado Hacer funcion auxiliar listaDeTuplas(dicc)}
{}

\operacion{HayMas?}
{    \param{in}{$it$}{itDiccLog($\kappa, \alpha$)}}
{bool}
{true}
{$res \igobs hayMas?(it)$}
{\bigo(1)}
{}
{Devuelve true si hay elementos para avanzar}

\operacion{Actual}
{   \param{in}{$it$}{itDiccLog($\kappa, \alpha$)}}
{tupla(clave: $\kappa$, significado: $\alpha$)}
{$hayMas?(it)$}
{alias($res \igobs actual(it)$)}
{\bigo(1)}
{$res$.significado es una referencia al significado de diccionario.
    \cuidado ver como decir bien esto}
{}

\operacion{Avanzar}
{   \param{in/out}{$it$}{itDiccLog($\kappa, \alpha$)}}
{}
{$it \igobs it_0 \land hayMas?(it)$}
{$it \igobs avanzar(it_0)$}
{\bigo(1)}
{}
{Avanza a la siguiente posición del iterador}

\operacion{EliminarSiguiente}
{   \param{in/out}{$it$}{itDiccLog($\kappa, \alpha$)}}
{}
{$it \igobs it_0 \land hayMas?(it)$}
{$it \igobs eliminar(it_0)$}
{\bigo($log(n)$), donde $n = $ cantidad de elementos en el 
    diccionario sobre el que se itera \cuidado}
{}
{Elimina del diccionario la clave del siguiente elemento}




\subsection{Representación del diccionario}

\serepresenta{diccLog($\kappa, \alpha$)}{avl}
\donde{avl}{tupla(\\
    $raiz$: puntero(nodo),\\
    $max$: puntero(nodo), $min$: puntero(nodo) )}
\donde{nodo}{tupla(\\
    $clave$: $\kappa$, $valor$: $\alpha$,\\
    $menor$: nodo, $mayor$: nodo, $padre$: nodo\\
    $fdb$: nat )}


\subsubsection{Invariante de representación}

\begin{Rep}{$avl$}{$a$}
    \repfunc{ raiz es null (y max y min tambien son null) $\lor_L$ }
    {
        a.raiz = NULL \implies (a.max = NULL \land a.min = NULL)
    }
    \repfunc{ para cada nodo el factor de balanceo esta entre -1 y 1 }
    {
        fdbsEnRango(a.raiz)
    }
    \repfunc{ para cada nodo el factor de balanceo es igual a la diferencia 
        de altura de sus dos hijos }
    {
        fdbsCoinciden(a.raiz)
    }
    \repfunc{ para cada nodo, si tiene un nodo menor, su valor es mayor al 
        de todos los nodos (del maximo) de la rama menor }
    {
        menoresSonMenores(a.raiz)
    }
    \repfunc{ para cada nodo, si tiene un nodo mayor, su valor es menor al 
        de todos los nodos (del minimo) de la rama mayor }
    {
        mayoresSonMayores(a.raiz)
    }
    \repfunc{ el padre de raiz siembre debe ser null }
    {
        a.raiz \neq NULL \implies (*a.raiz).padre = NULL
    }
    \repfunc{ para cada nodo n, si tiene mayor o menor, sus padres debe ser n }
    {
        a.raiz \neq NULL \implies padresCorrectos(a.raiz)
    }
    \repfunc{ para cada dos nodos distintos, $n_1$ y $n_2$, sus hijos deben ser distintos }
    {
        verificarHijos(a.raiz, a.raiz)
    }
    \repfunc{ para cada nodo ninguno puede apuntar a la raiz // esto deberia estar
        demas porque si el padre de la raiz debe ser null ya ningun nodo podria
        tenerlo de hijo }
    { }
    \repfunc{ max es igual al nodo con la clave mas grande }
    {
        a.raiz \neq NULL \implies a.max = \&maximo(a.raiz)
    }
    \repfunc{ min es igual al nodo con la clave mas pequeña }
    {
        a.raiz \neq NULL \implies a.min = \&minimo(a.raiz)
    }

\end{Rep}

\subsubsection{Operaciones auxiliares del invariante de representación}

\tadOperacion{fdbsEnRango}
{puntero(nodo)/n}
{bool}
{}

\tadOperacion{fdbsCoinciden}
{puntero(nodo)/n}
{bool}
{}

\tadOperacion{atura}
{puntero(nodo)/n}
{nat}
{}

\tadOperacion{menoresSonMenores}
{puntero(nodo)/n}
{bool}
{}

\tadOperacion{minimo}
{puntero(nodo)/n}
{nodo}
{$n \neq NULL$}

\tadOperacion{mayoresSonMayores}
{puntero(nodo)/n}
{bool}
{}

\tadOperacion{maximo}
{puntero(nodo)/n}
{nodo}
{$n \neq NULL$}

\tadOperacion{padresCorrectos}
{puntero(nodo)/n}
{bool}
{$n \neq NULL$}

\tadOperacion{verificarHijos}
{puntero(nodo)/r, puntero(nodo)/n}
{bool}
{}

\tadOperacion{hijosDistintos}
{nodo/a, nodo/b}
{bool}
{}

\tadAxiomas[$\forall$ puntero(nodo) $n$]

\tadAxioma{fdbsEnRango(n)}{$
    \IFLM n = NULL THEN true ELSE \\
    \hspace*{2em} -1 \leq (*n).fdb \leq 1 \land fdbsEnRango((*n).menor) \land fdbsEnRango((*n).mayor) \\
    FI
$}

\tadAxioma{fdbsCoinciden(n)}{$
    \IFLM n = NULL THEN true ELSE \\
    \hspace*{2em} (*n).fdb = altura((*n).menor) - altura((*n).mayor) \\
    \hspace*{2em} \land fdbsCoinciden((*n).menor) \land fdbsCoinciden((*n).mayor) \\
    FI
$}

\tadAxioma{altura(n)}{$
    \IFLM n = NULL THEN 0 ELSE \\
    \hspace*{2em} 1 + max(altura((*n).menor), altura((*n).mayor)) \\
    FI
$}

\tadAxioma{menoresSonMenores(n)}{$
    \IFLM n = NULL \lor (*n).menor = NULL THEN true ELSE \\
    \hspace*{2em} maximo((*n).menor).clave < (*n).clave \\
    \hspace*{2em} \land menoresSonMenores((*n).menor) \land menoresSonMenores((*n).mayor) \\
    FI
$}

\tadAxioma{maximo(n)}{$
    \IFLM (*n).mayor = NULL THEN (*n) ELSE \\
    \hspace*{2em} maximo((*n).mayor) \\
    FI
$}

\tadAxioma{mayoresSonMayores(n)}{$
    \IFLM n = NULL \lor (*n).mayor = NULL THEN true ELSE \\
    \hspace*{2em} minimo((*n).mayor).clave < (*n).clave \\
    \hspace*{2em} \land mayoresSonMayores((*n).menor) \land mayoresSonMayores((*n).mayor) \\
    FI
$}

\tadAxioma{minimo(n)}{$
    \IFLM (*n).menor = NULL THEN (*n) ELSE \\
    \hspace*{2em} minimo((*n).menor) \\
    FI
$}

\tadAxioma{padresCorrectos(n)}{$
    ((*n).menor \neq NULL \implies ( (*n).menor.padre = n \land padresCorrectos((*n).menor) ) \\
    \land 
    ((*n).mayor \neq NULL \implies ( (*n).mayor.padre = n \land padresCorrectos((*n).mayor) )
$}

\tadAxioma{verificarHijos(r, n)}{$
    \IFLM r = NULL \lor n = NULL THEN true ELSE \\
    \hspace*{2em} (r \neq n \implies hijosDistintos(*r, *n)) \\
    \hspace*{2em} \land verificarHijos((*r).menor, n) \\
    \hspace*{2em} \land verificarHijos((*r).mayor, n) \\
    \hspace*{2em} \land verificarHijos(r, (*n).menor) \\
    \hspace*{2em} \land verificarHijos(r, (*n).mayor) \\
    FI
$}

\tadAxioma{hijosDistintos(a, b)}{$
    a.menor \neq NULL \implies \\ 
    ( a.menor \neq a.mayor \land a.menor \neq b.menor \land a.menor \neq b.mayor ) \\
    a.mayor \neq NULL \implies \\
    ( a.mayor \neq b.menor \land a.mayor \neq b.mayor ) \\
    b.menor \neq NULL \implies \\
    ( b.menor \neq b.mayor )
$}

\subsubsection{Función de abstracción}

\begin{ABS}{$a$}{$avl$}{$d$}{$dicc$}
    \absfunc{}
    {
        (\forall c : \kappa)\ def?(c, d) \Leftrightarrow existe(c, a.raiz)\ \land_L
    }
    \absfunc{}
    {
        (\forall c : \kappa)\ def?(c, d) \implies obtener(c, d) = obtener(c, a.raiz)
    }
\end{ABS}

\subsubsection{Operaciones auxiliares de la función de abstracciónn}

\tadOperacion{existe}
{$\kappa$/c, puntero(nodo)/n}
{bool}
{}

\tadOperacion{obtener}
{$\kappa$/c, puntero(nodo)/n}
{$\alpha$}
{existe(c, n)}

\tadAxiomas[$\forall$ puntero(nodo) $n$, $\kappa\ c$]

\tadAxioma{existe(c, n)}{$
    \IFLM n = NULL THEN false ELSE \\
    \hspace*{2em} (*n).clave = c \lor_L existe(c, (*n).menor) \lor existe(c, (*n).mayor) \\
    FI
$}

\tadAxioma{obtener(c, n)}{$
    \IFLM (*n).clave = c THEN (*n).valor ELSE \\
    \hspace*{2em} \IFLM existe(c, (*n).menor) THEN \\
    \hspace*{4em}     obtener(c, (*n).menor) \\
    \hspace*{2em} ELSE \\
    \hspace*{4em}     obtener(c, (*n).mayor) \\
    \hspace*{2em} FI \\
    FI
$}

\subsection{Representación del iterador}


\subsection{Algoritmos}

\subsection{Servicios usados}


