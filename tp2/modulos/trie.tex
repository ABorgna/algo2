\section{diccTrie($\alpha$)}

El módulo diccTrie provee un diccionario con claves de tipo String y acceso, inserción y borrado en \bigo($L$), donde $L$ es el largo máximo de las claves.

\subsection{Interfaz}

\begin{iparamformales}{$\alpha$}

\end{iparamformales}

\iusa{}
\iseexplica{Diccionario($string, \alpha$)}
\igenero{diccTrie($\alpha$)}
\ioperaciones

\operacion{NuevoDiccTrie}
{}
{diccTrie($\alpha$)}
{true}
{$res \igobs vacio$}
{\bigo(1)}
{}
{Crea un diccionario vacio}

\operacion{Definir}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string},
    \param{in}{$v$}{$\alpha$}}
{}
{$d \igobs d_0 \land \neg def?(c,d)$}
{$d \igobs definir(c, v, d_0)$}
{\bigo($L$)}
{}
{Modifica el diccionario agregando o reemplazando el significado de una clave 
    con un nuevo valor}

\operacion{Definido?}
{   \param{in}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{bool}
{true}
{$res \igobs def?(c, d)$}
{\bigo($L$)}
{}
{Devuelve true si una clave se encuentra definida en el diccionario}

\operacion{Obtener}
{   \param{in}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{$\alpha$}
{$def?(c, d)$}
{$res$ \igobs $obtener(c, d)$}
{\bigo($L$)}
{}
{Devuelve el significado definido para la clave $c$}

\operacion{Borrar}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{}
{$d \igobs d_0 \land def?(c, d)$}
{$d \igobs borrar(c, d_0)$}
{\bigo($L$)}
{}
{Borra el significado asociado a la clave $c$}

\operacion{Maximo}
{   \param{in}{$d$}{diccLog($\alpha$)}}
{tupla(clave: string, significado: $\alpha$)}
{$\neg (d \igobs vacio)$}
{$res \igobs tupla(maximo(d), obtener(maximo(d)))$}
{\bigo(1)}
{}
{Obtiene una tupla de la clave y el significado del elemento con la clave 
    mas grande en el diccionario}

\operacion{Minimo}
{   \param{in}{$d$}{diccLog($\alpha$)}}
{tupla(clave: string, significado: $\alpha$)}
{$\neg (d \igobs vacio)$}
{$res \igobs tupla(minimo(d), obtener(minimo(d)))$}
{\bigo(1)}
{}
{Obtiene una tupla de la clave y el significado del elemento con la clave 
    mas pequeña en el diccionario}


\subsection{Representación}
\serepresenta{diccTrie($\alpha$)}{trie}
\donde{trie}{tupla(\\
    $raiz$: puntero(nodo),\\
    $minimo$: clavevalor,
    $maximo$: clavevalor }
\donde{nodo}{tupla(\\
    $valor$: $\alpha$,\\
    $hijos$: arreglo\_estático[256] (puntero(nodo)) )}
\donde{clavevalor}{tupla(\\
    $clave$: string,\\
    $valor$: $\alpha$ )}
    


\subsubsection{Invariante de representación}
\begin{Rep}{estrDic}{e}
  \repfunc{Raíz es distinto de NULL}
    {e.raiz != NULL}
   \repfunc{El valor de la raíz es NULL}
    {e.raiz.valor == NULL}
  \repfunc{Existe un \'unico camino entre cada nodo y el nodo ra\'iz (no hay ciclos)}
    {noHayCiclos( ag(\emptyset , e.raiz ) , e.raiz)}
  \repfunc{Todos los nodos hojas, es decir, todos los que tienen su arreglo hijos con todas sus posiciones en NULL, tienen que tener un valor distinto de NULL.}
    {todasLasHojasTienenValor(e)}
  \repfunc{Los nodos minimo y maximo son los correspondientes}
    {e.minimo==minimo(e.raiz) \land e.maximo==maximo(e.raiz)}

\end{Rep}

\subsubsection{Operaciones auxiliares del invariante de Representaci\'on}

  \tadOperacion{noHayCiclos}{conjunto(puntero(nodo)), puntero(nodo)}{bool}{}
  \tadAxioma{noHayCiclos($p, q$)}{auxNoHayCiclos($p,q,0$)}
  \tadOperacion{auxNoHayCiclos}{conjunto(puntero(nodo)), puntero(nodo), nat}{bool}{}
  \tadAxioma{auxNoHayCiclos($p ,q , n$)}{\IF $*q.hijos[n] \in p$ THEN false ELSE {\IF *q.hijos[n]=NULL THEN {\IF $n<255$ $\land$ auxNoHayCiclos($p ,q , n+1$) THEN true ELSE {\IF n==255 THEN true ELSE false FI} FI} ELSE {\IF $n<255$ $\land$ noHayCiclos($ag(p, *q.hijos[n]), q.hijos[n]$) $\land$ auxNoHayCiclos($p ,q , n+1$) THEN true ELSE {\IF n==255 $\land$ noHayCiclos($ag(p, *q.hijos[n]), *q.hijos[n]$) THEN true ELSE false  FI} FI} FI} FI}  
  
 
  
 \tadOperacion{maximo}{puntero(nodo)}{clavevalor}{}
  \tadAxioma{maximo($p$)}{\IF tieneHijos(p)==false THEN (NULL,p.valor) ELSE (chr(auxMaximo(p,255))+maximo(*p.hijos[auxMaximo(p,255)]).clave), *p.hijos[auxMaximo(p,255)]).valor) FI}
   \tadOperacion{auxMaximo}{puntero(nodo), nat}{nat}{}
  \tadAxioma{auxMaximo($p , n$)}{\IF *p.hijos[n]==NULL THEN auxMinimo(p,n-1) ELSE n FI} 
  
  \tadOperacion{minimo}{puntero(nodo)}{clavevalor}{}
  \tadAxioma{minimo($p$)}{\IF tieneHijos(p)==false  THEN (NULL,p.valor) ELSE {\IF *p.valor==NULL THEN (chr(auxMinimo(p,0))+minimo(*p.hijos[auxMinimo(p,0)]).clave), *p.hijos[auxMinimo(p,0)]).valor) ELSE (NULL,p.valor) FI} FI} 
   \tadOperacion{auxMinimo}{puntero(nodo), nat}{nat}{}
  \tadAxioma{auxMinimo($p , n$)}{\IF *p.hijos[n]==NULL THEN auxMinimo(p,n+1) ELSE n FI}
  
    \tadOperacion{todasLasHojasTienenValor}{trie}{bool}{}
  \tadAxioma{todasLasHojasTienenValor($e$)}{{\IF tieneHijos(e.raiz)==false THEN true ELSE auxTodasLasHojasTienenValor($e.raiz, 0$) FI}}
  \tadOperacion{auxTodasLasHojasTienenValor}{puntero(nodo), nat}{bool}{}
  \tadAxioma{auxTodasLasHojasTienenValor($p, n$)}{\IF $tieneHijos(p)==false$ THEN {\IF *p.valor==NULL THEN false ELSE true FI} ELSE {\IF *p.hijos[n]=NULL THEN {\IF $n<255$ $\land$ auxTodasLasHojasTienenValor($p, n+1$) THEN true ELSE {\IF n==255 THEN true ELSE false FI} FI} ELSE {\IF $n<255$ $\land$ auxTodasLasHojasTienenValor($*p.hijos[n], 0$) $\land$ auxTodasLasHojasTienenValor($p, n+1$) THEN true ELSE {\IF n==255 $\land$ auxTodasLasHojasTienenValor($*p.hijos[n],0$) THEN true ELSE false  FI} FI} FI} FI}  
  
  
   \tadOperacion{tieneHijos}{puntero(nodo)}{bool}{}
  \tadAxioma{tieneHijos($p$)}{auxTieneHijos($p,0$)}
  \tadOperacion{auxTieneHijos}{puntero(nodo), nat}{bool}{}
  \tadAxioma{auxTieneHijos($p, n$)}{\IF $n<255$ $\land$ *p.hijos[n]=NULL $\land$ auxTieneHijos($p, n+1$)==false  THEN false ELSE {\IF n==255 $\land$ *p.hijos[n]==NULL THEN false ELSE true FI} FI}
 
 
 
  
 

\subsubsection{Función de abstracción}

\begin{ABS}{e}{estrDicc}{d}{dicc(string,$\alpha$)}

  \absfunc{}{(\forall s:string)((definido?(s,d)) \Leftrightarrow ((s \in e.claves) \yluego ((\exists n: nodo)((n \in todasLasHojas(e)) \yluego n.valor = obtener(s,d))) )}
  \absfunc{}{(\exists i:nat)(i \in \{0..\vert e.claves \vert  \})  \Rightarrow  (e.claves[i] = c \yluego significado(c,d) = leer(e.clave).valor)}
\end{ABS}

\subsubsection{Representacion del iterador de Claves del diccTrie($\alpha$)}

\serepresenta{itClaves($\alpha$)}{puntero(nodo)}
Su Rep y Abs son los de itLista($\alpha$) definido en el apunte de iteradores para el modulo Lista Enlazada.

\subsection{Algoritmos}
\algoritmo{iNuevoDiccTrie}{
        }{diccTrie($\alpha$)}{\bigo(1)}{
    \var $n : nodo$    
    \State $ n \gets crearNodo()$                   		  			\comment \bigo(1)    
    \State $res.raiz \gets *n$                     						\comment \bigo(1)
    \State $res.claves \gets NULL$                            \comment \bigo(1)
    \State $res.minimo.valor \gets NULL$                     			\comment \bigo(1)  
    \State $res.minimo.clave \gets NULL$                     			\comment \bigo(1) 
    \State $res.maximo.valor \gets NULL$                     			\comment \bigo(1)  
    \State $res.maximo.clave \gets NULL$                     			\comment \bigo(1)                             
}{6 * \bigo(1) = \bigo(1)}

\algoritmo{iDefinir}
{   \param{in/out}{$e$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string},
    \param{in}{$v$}{$\alpha$}}
{}{}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1) 
	\var $p : puntero(nodo)$ 
	\State $ p \gets e.raiz$											\comment \bigo(1) 
	\var $n : nodo$ 
	\While{$i<(longitud(c))$}
   		\Statex             \comment El loop se repite longitud de la clave veces
     	\If{$p.hijos[ord(s[i])] == NULL$}                     			\comment \bigo(1)
        \State $n \gets crearNodo()$      							\comment \bigo(1)
        \State $p.hijos[ord(s[i])] \gets \&n$              			\comment \bigo(1)
     	\EndIf
     	\State $p \gets p.hijos[ord(s[i])]$								\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1) 
  \EndWhile		
	\State $*p.valor \gets v)$										\comment \bigo(1)
  \If{$c<e.minimo.clave\vert\vert e.maximo.clave==NULL $}                     					\comment \bigo(1)
    \State $e.minimo.clave \gets c$     				 	\comment \bigo(1)
    \State $e.minimo.valor \gets v$     				 \comment \bigo(1)
  \EndIf	
  \If{$c>e.maximo.clave \vert\vert e.maximo.clave==NULL $}                     					\comment \bigo(1)
    \State $e.maximo.clave \gets c$     				 	\comment \bigo(1)
    \State $e.maximo.valor \gets v$     				 	\comment \bigo(1)
  \EndIf
  \State $AgregarAdelante(c, e.claves)$					 \comment \bigo(1)
  \State $p.clave \gets crearIt(e.claves)$        \comment \bigo(1)

}	{  2* \bigo(1) + L * (5 * \bigo(1)) + 7 * \bigo(1) = \bigo(L) }

\algoritmo{iDefinido?}
{   \param{in/out}{$e$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
    {bool}
    {\bigo(L)}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1) 
	\var $p : puntero(nodo)$ 
	\State $ p \gets e.raiz$											\comment \bigo(1)    
	\While{$i<(longitud(c)) \&\& res==NULL$}
	\Statex             \comment El loop se repite longitud de la clave veces o menos en caso de que res se vuelva false
		 \If{$p.hijos[ord(s[i])] != NULL$}                     			\comment \bigo(1)
		 	\State $p \gets p.hijos[ord(s[i])]$							\comment \bigo(1)
		 \Else
            \State $res \gets false$  									\comment \bigo(1)
     	 \EndIf	
     	\State $i++$   													\comment \bigo(1) 
    \EndWhile		
	\State $res \gets p.valor != NULL$									\comment \bigo(1)	

}	{  2* \bigo(1) + L * (4 * \bigo(1)) + \bigo(1) = \bigo(L) }


\algoritmo{iObtener}
{   \param{in/out}{$e$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
    {$\alpha$}
    {\bigo(L)}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1) 
	\var $p : puntero(nodo)$ 
	\State $ p \gets e.raiz$											\comment \bigo(1)  
	\While{$i<(longitud(c))$}
     	\Statex             \comment El loop se repite longitud de la clave veces
     	\State $p \gets p.hijos[ord(s[i]))$								\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1) 
    \EndWhile		
	\State $res \gets (*p).valor)$										\comment \bigo(1)												 

}	{  2* \bigo(1) + L * (2 * \bigo(1)) + \bigo(1) = \bigo(L) }

\algoritmo{iBorrar}
{   \param{in/out}{$e$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
    {}
    {\bigo(L)}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1) 
	\var $p : puntero(nodo)$ 
	\State $ p \gets e.raiz$											\comment \bigo(1)  
	\var $pi: pila(tupla(punte: puntero(nodo), siguiente: nat))$ 
	\While{$i<(longitud(c)-1)$}
     	\Statex             \comment El loop se repite longitud de la clave veces
     	\State $p \gets p.hijos[ord(s[i]))$								\comment \bigo(1)
     	\State $apilar(pi, (p,s[i+1])) $								\comment \bigo(copy(tupla(punte: puntero(nodo), siguiente: nat))) 
     	\State $i++$   													\comment \bigo(1) 
    \EndWhile	
    \State $EliminarSiguiente(p.clave)$            \comment \bigo(1)
    \State $p.clave \gets NULL$               \comment \bigo(1)
    \State $p \gets p.hijos[ord(s[i]))$								\comment \bigo(1)
     \State $apilar(pi, (p,NULL)) $							\comment \bigo(copy(tupla(punte: puntero(nodo), siguiente: nat)))	
   \While{$(\neq TieneHijos(*(tope(pi).punte))) \& \& ((*(tope(pi).punte)).clave==NULL)$}
     	\Statex             \comment El loop se repite longitud de la clave veces como mucho
 
     	\State $p \gets desapilar(pi)$								\comment \bigo(1)
     	  \State $(*(tope(pi).punte)).hijos[*(tope(pi).siguiente)] == NULL$							\comment \bigo(1)	
    \EndWhile	
    \If{$\neg tieneHijos(e.raiz)$}                     			\comment \bigo(1)
		 	\State $e.maximo \gets NULL$							\comment \bigo(1)
	\State $e.minimo \gets NULL$							\comment \bigo(1)
	\Else
         \State $ p \gets e.raiz$	\comment \bigo(1)
         \var $s : string$ 
         \State $ s \gets <>$	\comment \bigo(1)
         \While{$(*p).valor==NULL $}
     		\Statex             \comment El loop se repite L veces como mucho
     		\State $s \gets s+chr(MenorHijo(*p))$								\comment \bigo(1)	
     		\State $p \gets MenorHijo(*p)$								\comment \bigo(1)	
     				
    	\EndWhile		
    	\State $e.minimo.clave \gets s$								\comment \bigo(1)	
    	\State $e.minimo.valor \gets (*p).valor$								\comment \bigo(1)	
    	\State $ s \gets <>$	\comment \bigo(1)
    	\While{$TieneHijos(*p)$}
     		\Statex             \comment El loop se repite L veces como mucho
     		\State $s \gets s+chr(MayorHijo(*p))$								\comment \bigo(1)	
     		\State $p \gets MayorHijo(*p)$								\comment \bigo(1)	
     				
    	\EndWhile		
    	\State $e.maximo.clave \gets s$								\comment \bigo(1)	
    	\State $e.maximo.valor \gets (*p).valor$								\comment \bigo(1)	
    	
     \EndIf
												 

}	{  2* \bigo(1) + L * (2 * \bigo(1) + \bigo(copy(tupla(punte: puntero(nodo), siguiente: nat)))) + \bigo(1) +\bigo(copy(tupla(punte: puntero(nodo), siguiente: nat))))+ L * 2 * \bigo(1)+ 7 * \bigo(1)== \bigo(L) en caso de que el arbol este vacio, el el otro caso es 
2* \bigo(1) + L * (2 * \bigo(1) + \bigo(copy(tupla(punte: puntero(nodo), siguiente: nat)))) + \bigo(1) +\bigo(copy(tupla(punte: puntero(nodo), siguiente: nat))))+ L * 2 * \bigo(1)+\bigo(1)+2* L * 2 * \bigo(1) +2 * 2 *big O(1) == \bigo(L)}

\algoritmo{iMaximo}{
\param{in/out}{$e$}{diccTrie($\alpha$)}
        }{tupla(clave: string, significado: $\alpha$)}{\bigo(1)}{  
    \State $ res \gets e.maximo$                   		  			\comment \bigo(1)                             
}{ \bigo(1) = \bigo(1)}

\algoritmo{iMinimo}{
\param{in/out}{$e$}{diccTrie($\alpha$)}
        }{tupla(clave: string, significado: $\alpha$)}{\bigo(1)}{  
    \State $ res \gets e.minimo$                   		  			\comment \bigo(1)                             
}{ \bigo(1) = \bigo(1)}





\subsubsection{Funciones auxiliares de los algoritmos}

\algoritmo{iCrearNodo}{
}{nodo}{\bigo(1)}
  {
    \var $d : arreglo_est\acute{a}tico[256] (puntero(nodo))$
    \var $i : nat$
    \State $i \gets 0)$                									\comment \bigo(1)

    \While{$i<256$}
     	\Statex             \comment El loop se repite 256 veces
     	\State $d[i] \gets NULL)$										\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1) 
    \EndWhile						
    \State $res.hijos \gets d)$											\comment \bigo(1) 
    \State $res.valor \gets NULL)$   									\comment \bigo(1)
    \State $res.clave \gets NULL)$                    \comment \bigo(1) 
}{   \bigo(1) + 256 * (2 * \bigo(1)) + 3 * \bigo(1) = \bigo(1) }

\algoritmo{iTieneHijos}{
\param{in}{$n$}{nodo}
}{bool}{\bigo(1)}
  {
    \var $i : nat$
    \State $i \gets 0)$                									\comment \bigo(1)
    \State $res \gets false$										\comment \bigo(1)
    \While{$i<256$}
     	\Statex             \comment El loop se repite 256 veces
 		\If{$n.hijos[i] != NULL$}                     			\comment \bigo(1)
		 	\State $res \gets true$										\comment \bigo(1)
     	 \EndIf	 													 
    \EndWhile						
}{  2* \bigo(1) + 256 * (2 * \bigo(1))  = \bigo(1) }

\algoritmo{iMenorHijo}{
\param{in}{$n$}{nodo}
}{nat}{\bigo(1)}
  {
    \var $i : nat$
    \State $i \gets 0)$                									\comment \bigo(1)
    \State $res \gets 256$												\comment \bigo(1)
    \While{$i<256$}
     	\Statex             \comment El loop se repite 256 veces
 		\If{$n.hijos[i] != NULL \&\& i<res$}                     			\comment \bigo(1)
		 	\State $res \gets i$										\comment \bigo(1)
     	 \EndIf	 													 
    \EndWhile						
}{  2* \bigo(1) + 256 * (2 * \bigo(1))  = \bigo(1) }

\algoritmo{iMayorHijo}{
\param{in}{$n$}{nodo}
}{nat}{\bigo(1)}
  {
    \var $i : nat$
    \State $i \gets 0)$                									\comment \bigo(1)
    \State $res \gets 0$												\comment \bigo(1)
    \While{$i<256$}
     	\Statex             \comment El loop se repite 256 veces
 		\If{$n.hijos[i] != NULL \&\& i>res$}                     			\comment \bigo(1)
		 	\State $res \gets i$										\comment \bigo(1)
     	 \EndIf	 													
    \EndWhile						
}{  2* \bigo(1) + 256 * (2 * \bigo(1))  = \bigo(1) }


\subsection{Servicios usados}

\usaServicio{pila ($\alpha$)}
\usaServicio{arreglo$\_$estatico ($\alpha$)}
\usaServicio{AgregarAdelante(itLista($\alpha$))}
\usaServicio{EliminarSiguiente(itLista($\alpha$))}

