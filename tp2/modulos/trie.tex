\section{diccTrie($\alpha$)}

El módulo diccTrie provee un diccionario con claves de tipo String y acceso, inserción y borrado en \bigo($L$), donde $L$ es el largo máximo de las claves.

\subsection{Interfaz}

\begin{iparamformales}{$\alpha$}

\end{iparamformales}

\iusa{}
\iseexplica{Diccionario($string, \alpha$)}
\igenero{diccTrie($\alpha$)}
\ioperaciones

\operacion{NuevoDiccTrie}
{}
{diccTrie($\alpha$)}
{true}
{$res \igobs vacio$}
{\bigo(1)}
{}
{Crea un diccionario vacio}

\operacion{Definir}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string},
    \param{in}{$v$}{$\alpha$}}
{}
{$d \igobs d_0 \land \neq def?(c, d)$}
{$d \igobs definir(c, v, d_0)$}
{\bigo($L$)}
{Modifica el diccionario agregando o reemplazando el significado de una clave
    con un nuevo valor}

\operacion{Definido?}
{   \param{in}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{bool}
{true}
{$res \igobs def?(c, d)$}
{\bigo($L$)}
{}
{Devuelve true si una clave se encuentra definida en el diccionario}

\operacion{Obtener}
{   \param{in}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{$\alpha$}
{$def?(c, d)$}
{$res$ \igobs $obtener(c, d)$}
{\bigo($L$)}
{}
{Devuelve el significado definido para la clave $c$}

\operacion{Borrar}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
{}
{$d \igobs d_0 \land def?(c, d)$}
{$d \igobs borrar(c, d_0)$}
{\bigo($L$)}
{}
{Borra el significado asociado a la clave $c$}

\operacion{Maximo}
{   \param{in}{$d$}{diccLog($\alpha$)}}
{tupla(clave: string, significado: $\alpha$)}
{$\neg (d \igobs vacio)$}
{$siguiente(res) \igobs tupla(maximo(d), obtener(maximo(d)))$}
{\bigo(1)}
{}
{Obtiene una tupla de la clave y el significado del elemento con la clave
    mas grande en el diccionario}

\operacion{Minimo}
{   \param{in}{$d$}{diccLog($\alpha$)}}
{tupla(clave: string, significado: $\alpha$)}
{$\neg (d \igobs vacio)$}
{$siguiente(res) \igobs tupla(minimo(d), obtener(minimo(d)))$}
{\bigo(1)}
{}
{Obtiene una tupla de la clave y el significado del elemento con la clave
    mas pequeña en el diccionario}

\tadOperacion{minimo}
{diccLog($\alpha$)/d}
{$\kappa$}
{$\neg vacia?(claves(d))$}
\tadAxioma{minimo(d)}{$
    \IFLM len(claves(d)) = 1 THEN prim(claves(d)) ELSE  \\
    \hspace*{2em}    \IFLM prim(claves(d)) > minimo(borrar(prim(claves(d)), d)) THEN \\
    \hspace*{4em}        minimo(borrar(prim(claves(d)), d)) \\
    \hspace*{2em}    ELSE \\
    \hspace*{4em}        prim(claves(d)) \\
    \hspace*{2em}    FI \\
    FI
$}
\tadOperacion{maximo}
{diccLog($\kappa\ \alpha$)/d}
{$\kappa$}
{$\neg vacia?(claves(d))$}
\tadAxioma{maximo(d)}{$
    \IFLM len(claves(d)) = 1 THEN prim(claves(d)) ELSE  \\
    \hspace*{2em}    \IFLM prim(claves(d)) > maximo(borrar(prim(claves(d)), d)) THEN \\
    \hspace*{4em}        prim(claves(d)) \\
    \hspace*{2em}    ELSE \\
    \hspace*{4em}        maximo(borrar(prim(claves(d)), d)) \\
    \hspace*{2em}    FI \\
    FI
$}

\subsection{Representación}
\serepresenta{diccTrie($\alpha$)}{trie}
\donde{trie}{tupla(\\
    $raiz$: puntero(nodo),\\
    $minimo$: clavevalor,
    $maximo$: clavevalor )}
\donde{nodo}{tupla(\\
    $valor$: $\alpha$,\\
    $hijos$: arreglo\_estático[256] (puntero(nodo)) )}
\donde{clavevalor}{tupla(\\
    $clave$: string,\\
    $valor$: $\alpha$ )}



\subsubsection{Invariante de representación}

\begin{Rep}{estrDic}{e}{
  \repfunc{Raíz es distinto de NULL}
    {raiz != NULL}
  \repfunc{Existe un \'unico camino entre cada nodo y el nodo ra\'iz (no hay ciclos)}
    {noHayCiclos(e)}
  \repfunc{Todos los nodos hojas, es decir, todos los que tienen su arreglo hijos con todas sus posiciones en NULL, tienen que tener un valor distinto de NULL.}
    {todasLasHojasTienenValor(e)}
  \repfunc{En claves est\'a el camino que se recorre desde la ra\'z hasta cada nodo hoja}
   {hayHojas(e) $\Rightarrow$ $\vert$e.claves$\vert$ $>$ 0 \\ $\land$ ($\forall$ c : string)(c $\in$ caminosANodos(e)) $\Rightarrow$ (($\exists$ i: nat)(i $\in$ $\{$0.. $\vert$e.claves$\vert$ $\}$) $\Rightarrow$ (e.claves[i] $=$ c))}
  \repfunc{Los nodos minimo y maximo son los correspondientes}
    {}
\end{Rep}


 \subsubsection{Operaciones auxiliares del invariante de Representaci\'on}

  \tadOperacion{noHayCiclos}{puntero(nodo)}{bool}{}
  \tadAxioma{noHayCiclos($n,p$)}{($\exists$ n:nat)(($\forall$ c: string)($\vert$s$\vert$ = n $\Rightarrow$ leer($p,s$) = NULL))}
  \tadOperacion{leer}{puntero(nodo), string}{bool}{}
  \tadAxioma{leer($p,s$)}{\IF vacia?($s$) THEN p $\rightarrow$ valor ELSE {\IF p $\rightarrow$ hijos[prim(s)] = NULL THEN NULL ELSE leer(p $\rightarrow$ hijos[prim(s)], fin(s)) FI} FI}
  \tadOperacion{todosNull}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{todosNull($a$)}{auxTodosNull($a, 0$)}
  \tadOperacion{auxTodosNull}{arreglo(puntero(nodo)), nat}{bool}{}
  \tadAxioma{auxTodosNull($a, i$)}{\IF i < $\vert$a$\vert$ THEN a[i] == NULL $\land$ auxTodosNull($a, i+1$) ELSE a[i].valor == NULL FI}
  \tadOperacion{esHoja}{puntero(nodo)}{bool}{}
  \tadAxioma{esHoja($p$)}{\IF p == NULL THEN false ELSE todosNull(p.hijos) FI}
  \tadOperacion{todasLasHojas}{puntero(nodo), nat}{conj(nodo)}{}
  \tadAxioma{todasLasHojas($p, n$)}{\IF p == NULL THEN false ELSE {\IF esHoja($p$) THEN Ag(*p, vacio) ELSE auxTodasLasHojas((*p).hijos, 256) FI} FI}

  \tadOperacion{auxTodasLasHojas}{arreglo(puntero(nodo)), nat}{conj(nodo)}{}
  \tadAxioma{auxTodasLasHojas($a, n$)}{hojasDeHijos($a,n,0$)}

  \tadOperacion{hojasDeHijos}{arreglo(puntero(nodo)), nat, nat}{conj(nodo)}{}
  \tadAxioma{hojasDeHijos($a, n, i$)}{\IF i = n THEN $\emptyset$ ELSE todasLasHojas(a[i]) $\cup$ hojasDeHijos($a, n, (i+1)$) FI}

  \tadOperacion{todasLasHojasTienenValor}{puntero(nodo)}{bool}{}
  \tadAxioma{todasLasHojasTienenValor($p$)}{auxTodasLasHojasTienenValor(todasLasHojas($p, 256$))}

  \tadOperacion{auxTodasLasHojasTienenValor}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{auxTodasLasHojasTienenValor($a$)}{\IF |a| = 0 THEN true ELSE dameUno(a).valor != NULL $\land$ auxTodasLasHojasTienenValor(sinUno(a)) FI}

\tadOperacion{hayHojas}{puntero(nodo)}{bool}{}
Dada una estructura, indica si en la misma existe alg\'un nodo cuyo arreglo hijos tenga todas las posiciones NULL.
\tadOperacion{caminosANodos}{puntero(nodo)}{conj(string)}{}
Dada una estructura, devuelve un conjunto con el \'unico camino existente entre la raiz y cada hoja. El camino se obtiene de agregar la posici\'on del arreglo hijos por la cual hay que bajar en cada nivel de la estructura hasta llegar a la hoja, conviritendo en cada paso esa posici\'on en un \textsc{char} y junt\'andolos en un \textsc{string}.


\subsubsection{Función de abstracción}
 \begin{ABS}{e}{estrDicc}{d}{dicc(string,$\alpha$)}
   \absfunc{}{($\forall$ c:string)(definido?($c,d$)) = ($\exists$ n: nodo)(n $\in$ todasLasHojas($e$)) n.valor != NULL}
   \absfunc{}{($\exists$ i:nat)(i $\in$ \{0..$\vert$e.claves$\vert$ \}) $\Rightarrow$ e.claves[i] = c $\yluego$ significado($c,d$) = leer($e.clave$).valor}
 \end{ABS}




\subsection{Algoritmos}
\algoritmo{iNuevoDiccTrie}{
        }{diccTrie($\alpha$)}{\bigo(1)}{
    \var $n : nodo$
    \State $ n \gets crearNodo()$                   		  			\comment \bigo(1)
    \State $res.raiz \gets *n$                     						\comment \bigo(1)
    \State $res.minimo.valor \gets NULL$                     			\comment \bigo(1)
    \State $res.minimo.clave \gets NULL$                     			\comment \bigo(1)
    \State $res.maximo.valor \gets NULL$                     			\comment \bigo(1)
    \State $res.maximo.clave \gets NULL$                     			\comment \bigo(1)
}{6 * \bigo(1) = \bigo(1)}

\algoritmo{iDefinir}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string},
    \param{in}{$v$}{$\alpha$}}
{}{}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1)
	\var $p : puntero(nodo)$
	\State $ p \gets e.raiz$											\comment \bigo(1)
	\var $n : nodo$
	\While{$i<(longitud(c))$}
   		\Statex             \comment El loop se repite longitud de la clave veces
     	 \If{$p.hijos[ord(s[i]] == NULL$}                     			\comment \bigo(1)
            \State $n \gets crearNodo()$      							\comment \bigo(1)
           	\State $p.hijos[ord(s[i]) \gets \&n$              			\comment \bigo(1)
     	 \EndIf
     	\State $p \gets p.hijos[ord(s[i]))$								\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1)
    \EndWhile
	\State $*p.valor \gets v)$										\comment \bigo(1)
    \If{$c<trie.minimo.clave$}                     					\comment \bigo(1)
           \State $trie.minimo.clave \gets c$     				 	\comment \bigo(1)
             \State $trie.minimo.valor \gets v$     				 \comment \bigo(1)
       \EndIf
     \If{$c>trie.maximo.clave$}                     					\comment \bigo(1)
           \State $trie.maximo.clave \gets c$     				 	\comment \bigo(1)
           \State $trie.maximo.valor \gets v$     				 	\comment \bigo(1)
      \EndIf

}	{  2* \bigo(1) + L * (5 * \bigo(1)) + 7 * \bigo(1) = \bigo(L) }

\algoritmo{iObtener}
{   \param{in/out}{$d$}{diccTrie($\alpha$)},
    \param{in}{$c$}{string}}
    {$\alpha$}
    {\bigo(L)}
{
	\var $i : nat$
	\State $ i \gets 0$  												\comment \bigo(1)
	\var $p : puntero(nodo)$
	\State $ p \gets e.raiz$											\comment \bigo(1)
	\While{$i<(longitud(c))$}
     	\Statex             \comment El loop se repite longitud de la clave veces
     	\State $p \gets p.hijos[ord(s[i]))$								\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1)
    \EndWhile
	\State $res \gets *p.valor)$										\comment \bigo(1)

}	{  2* \bigo(1) + L * (2 * \bigo(1)) + \bigo(1) = \bigo(L) }



\subsubsection{Funciones auxiliares de los algoritmos}

\algoritmo{iCrearNodo}{
}{nodo}{\bigo(1)}
  {
    \var $d : arreglo_est\acute{a}tico[256] (puntero(nodo))$
    \var $i : nat$
    \State $i \gets 0)$                									\comment \bigo(1)

    \While{$i<256$}
     	\Statex             \comment El loop se repite 256 veces
     	\State $d[i] \gets NULL)$										\comment \bigo(1)
     	\State $i++$   													\comment \bigo(1)
    \EndWhile
    \State $res.hijos \gets d)$											\comment \bigo(1)
    \State $res.valor \gets NULL)$   									\comment \bigo(1)
}{   \bigo(1) + 256 * (2 * \bigo(1)) + 2 * \bigo(1) = \bigo(1) }

\subsection{Servicios usados}
